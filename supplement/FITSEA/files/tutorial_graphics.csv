,"Canvas and Drawables","Canvas and Drawables","<p>The Android framework APIs provides a set 2D drawing APIs that allow you to render your own custom graphics onto a canvas or to modify existing Views to customize their look and feel. When drawing 2D graphics, you'll typically do so in one of two ways:</p> 
 <ol type="a"> 
  <li>Draw your graphics or animations into a View object from your layout. In this manner, the drawing of your graphics is handled by the system's normal View hierarchy drawing process ¡ª you simply define the graphics to go inside the View.</li> 
  <li>Draw your graphics directly to a Canvas. This way, you personally call the appropriate class's <code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code> method (passing it your Canvas), or one of the Canvas <code>draw...()</code> methods (like <code><code><a href="../../../reference/android/graphics/Canvas.html#drawPicture(android.graphics.Picture, android.graphics.Rect)">drawPicture()</a></code></code>). In doing so, you are also in control of any animation.</li> 
 </ol> 
 <p>Option &quot;a,&quot; drawing to a View, is your best choice when you want to draw simple graphics that do not need to change dynamically and are not part of a performance-intensive game. For example, you should draw your graphics into a View when you want to display a static graphic or predefined animation, within an otherwise static application. Read <a href="#drawables">Drawables</a> for more information. </p> 
 <p>Option &quot;b,&quot; drawing to a Canvas, is better when your application needs to regularly re-draw itself. Applications such as video games should be drawing to the Canvas on its own. However, there's more than one way to do this:</p> 
 <ul> 
  <li>In the same thread as your UI Activity, wherein you create a custom View component in your layout, call <code><code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code></code> and then handle the <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code></code> callback.</li> 
  <li>Or, in a separate thread, wherein you manage a <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code> and perform draws to the Canvas as fast as your thread is capable (you do not need to request <code>invalidate()</code>).</li> 
 </ul> 
 ","SurfaceView","android.view.SurfaceView","class",0
,"Draw with a Canvas","On a SurfaceView","<h3 id="on-surfaceview">On a SurfaceView</h3> 
 <p>The <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code> is a special subclass of View that offers a dedicated drawing surface within the View hierarchy. The aim is to offer this drawing surface to an application's secondary thread, so that the application isn't required to wait until the system's View hierarchy is ready to draw. Instead, a secondary thread that has reference to a SurfaceView can draw to its own Canvas at its own pace.</p> 
 <p>To begin, you need to create a new class that extends <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code>. The class should also implement <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code>. This subclass is an interface that will notify you with information about the underlying <code><a href="../../../reference/android/view/Surface.html">Surface</a></code>, such as when it is created, changed, or destroyed. These events are important so that you know when you can start drawing, whether you need to make adjustments based on new surface properties, and when to stop drawing and potentially kill some tasks. Inside your SurfaceView class is also a good place to define your secondary Thread class, which will perform all the drawing procedures to your Canvas.</p> 
 <p>Instead of handling the Surface object directly, you should handle it via a <code><a href="../../../reference/android/view/SurfaceHolder.html">SurfaceHolder</a></code>. So, when your SurfaceView is initialized, get the SurfaceHolder by calling <code><code><a href="../../../reference/android/view/SurfaceView.html#getHolder()">getHolder()</a></code></code>. You should then notify the SurfaceHolder that you'd like to receive SurfaceHolder callbacks (from <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code>) by calling <code><a href="../../../reference/android/view/SurfaceHolder.html#addCallback(android.view.SurfaceHolder.Callback)">addCallback()</a></code> (pass it <var>this</var>). Then override each of the <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code> methods inside your SurfaceView class.</p> 
 <p>In order to draw to the Surface Canvas from within your second thread, you must pass the thread your SurfaceHandler and retrieve the Canvas with <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">lockCanvas()</a></code></code>. You can now take the Canvas given to you by the SurfaceHolder and do your necessary drawing upon it. Once you're done drawing with the Canvas, call <code><code><a href="../../../reference/android/view/SurfaceHolder.html#unlockCanvasAndPost(android.graphics.Canvas)">unlockCanvasAndPost()</a></code></code>, passing it your Canvas object. The Surface will now draw the Canvas as you left it. Perform this sequence of locking and unlocking the canvas each time you want to redraw.</p> 
 <p class="note"><strong>Note:</strong> On each pass you retrieve the Canvas from the SurfaceHolder, the previous state of the Canvas will be retained. In order to properly animate your graphics, you must re-paint the entire surface. For example, you can clear the previous state of the Canvas by filling in a color with <code><code><a href="../../../reference/android/graphics/Canvas.html#drawColor(int)">drawColor()</a></code></code> or setting a background image with <code><code><a href="../../../reference/android/graphics/Canvas.html#drawBitmap(android.graphics.Bitmap, android.graphics.Rect, android.graphics.RectF, android.graphics.Paint)">drawBitmap()</a></code></code>. Otherwise, you will see traces of the drawings you previously performed.</p> 
 <p>For a sample application, see the Lunar Lander game, in the SDK samples folder: <code>&lt;your-sdk-directory&gt;/samples/LunarLander/</code>. Or, browse the source in the <a href="../../../guide/samples/index.html">Sample Code</a> section.</p> 
 ","SurfaceView","android.view.SurfaceView","class",1
,"OpenGL ES","The Basics","<h2 id="basics">The Basics</h2> 
 <p>Android supports OpenGL both through its framework API and the Native Development Kit (NDK). This topic focuses on the Android framework interfaces. For more information about the NDK, see the <a href="../../../tools/sdk/ndk/index.html">Android NDK</a>. </p>
 <p>There are two foundational classes in the Android framework that let you create and manipulate graphics with the OpenGL ES API: <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>. If your goal is to use OpenGL in your Android application, understanding how to implement these classes in an activity should be your first objective. </p> 
 <dl> 
  <dt>
   <strong><code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code></strong>
  </dt> 
  <dd>
   This class is a 
   <code><a href="../../../reference/android/view/View.html">View</a></code> where you can draw and manipulate objects using OpenGL API calls and is similar in function to a 
   <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code>. You can use this class by creating an instance of 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and adding your 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">Renderer</a></code> to it. However, if you want to capture touch screen events, you should extend the 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> class to implement the touch listeners, as shown in OpenGL training lesson, 
   <a href="../../../training/graphics/opengl/touch.html">Responding to Touch Events</a>.
  </dd> 
  <dt>
   <strong><code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code></strong>
  </dt> 
  <dd>
   This interface defines the methods required for drawing graphics in a 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. You must provide an implementation of this interface as a separate class and attach it to your 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> instance using 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html#setRenderer(android.opengl.GLSurfaceView.Renderer)">GLSurfaceView.setRenderer()</a></code>. 
   <p>The <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> interface requires that you implement the following methods:</p> 
   <ul> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceCreated(javax.microedition.khronos.opengles.GL10, javax.microedition.khronos.egl.EGLConfig)">onSurfaceCreated()</a></code>: The system calls this method once, when creating the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. Use this method to perform actions that need to happen only once, such as setting OpenGL environment parameters or initializing OpenGL graphic objects. </li> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onDrawFrame(javax.microedition.khronos.opengles.GL10)">onDrawFrame()</a></code>: The system calls this method on each redraw of the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. Use this method as the primary execution point for drawing (and re-drawing) graphic objects.</li> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)">onSurfaceChanged()</a></code>: The system calls this method when the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> geometry changes, including changes in size of the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> or orientation of the device screen. For example, the system calls this method when the device changes from portrait to landscape orientation. Use this method to respond to changes in the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> container. </li> 
   </ul> 
  </dd> 
 </dl> 
 ","SurfaceView","android.view.SurfaceView","class",1
,"Canvas and Drawables","Canvas and Drawables","<p>The Android framework APIs provides a set 2D drawing APIs that allow you to render your own custom graphics onto a canvas or to modify existing Views to customize their look and feel. When drawing 2D graphics, you'll typically do so in one of two ways:</p> 
 <ol type="a"> 
  <li>Draw your graphics or animations into a View object from your layout. In this manner, the drawing of your graphics is handled by the system's normal View hierarchy drawing process ¡ª you simply define the graphics to go inside the View.</li> 
  <li>Draw your graphics directly to a Canvas. This way, you personally call the appropriate class's <code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code> method (passing it your Canvas), or one of the Canvas <code>draw...()</code> methods (like <code><code><a href="../../../reference/android/graphics/Canvas.html#drawPicture(android.graphics.Picture, android.graphics.Rect)">drawPicture()</a></code></code>). In doing so, you are also in control of any animation.</li> 
 </ol> 
 <p>Option &quot;a,&quot; drawing to a View, is your best choice when you want to draw simple graphics that do not need to change dynamically and are not part of a performance-intensive game. For example, you should draw your graphics into a View when you want to display a static graphic or predefined animation, within an otherwise static application. Read <a href="#drawables">Drawables</a> for more information. </p> 
 <p>Option &quot;b,&quot; drawing to a Canvas, is better when your application needs to regularly re-draw itself. Applications such as video games should be drawing to the Canvas on its own. However, there's more than one way to do this:</p> 
 <ul> 
  <li>In the same thread as your UI Activity, wherein you create a custom View component in your layout, call <code><code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code></code> and then handle the <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code></code> callback.</li> 
  <li>Or, in a separate thread, wherein you manage a <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code> and perform draws to the Canvas as fast as your thread is capable (you do not need to request <code>invalidate()</code>).</li> 
 </ul> 
 ","View","android.view.View","class",1
,"Canvas and Drawables","Draw with a Canvas","<h2 id="draw-with-canvas">Draw with a Canvas</h2> 
 <p>When you're writing an application in which you would like to perform specialized drawing and/or control the animation of graphics, you should do so by drawing through a <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code>. A Canvas works for you as a pretense, or interface, to the actual surface upon which your graphics will be drawn ¡ª it holds all of your &quot;draw&quot; calls. Via the Canvas, your drawing is actually performed upon an underlying <code><a href="../../../reference/android/graphics/Bitmap.html">Bitmap</a></code>, which is placed into the window.</p> 
 <p>In the event that you're drawing within the <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code></code> callback method, the Canvas is provided for you and you need only place your drawing calls upon it. You can also acquire a Canvas from <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">SurfaceHolder.lockCanvas()</a></code></code>, when dealing with a SurfaceView object. (Both of these scenarios are discussed in the following sections.) However, if you need to create a new Canvas, then you must define the <code><a href="../../../reference/android/graphics/Bitmap.html">Bitmap</a></code> upon which drawing will actually be performed. The Bitmap is always required for a Canvas. You can set up a new Canvas like this:</p> 
 <pre>
Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
Canvas c = new Canvas(b);
</pre> 
 <p>Now your Canvas will draw onto the defined Bitmap. After drawing upon it with the Canvas, you can then carry your Bitmap to another Canvas with one of the <code><code><a href="../../../reference/android/graphics/Canvas.html#drawBitmap(android.graphics.Bitmap, android.graphics.Matrix, android.graphics.Paint)">Canvas.drawBitmap(Bitmap,...)</a></code></code> methods. It's recommended that you ultimately draw your final graphics through a Canvas offered to you by <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">View.onDraw()</a></code></code> or <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">SurfaceHolder.lockCanvas()</a></code></code> (see the following sections).</p> 
 <p>The <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code> class has its own set of drawing methods that you can use, like <code>drawBitmap(...)</code>, <code>drawRect(...)</code>, <code>drawText(...)</code>, and many more. Other classes that you might use also have <code>draw()</code> methods. For example, you'll probably have some <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> objects that you want to put on the Canvas. Drawable has its own <code><code><a href="../../../reference/android/graphics/drawable/Drawable.html#draw(android.graphics.Canvas)">draw()</a></code></code> method that takes your Canvas as an argument.</p> 
 ","View","android.view.View","class",0
,"Draw with a Canvas","On a View","<h3 id="on-view">On a View</h3> 
 <p>If your application does not require a significant amount of processing or frame-rate speed (perhaps for a chess game, a snake game, or another slowly-animated application), then you should consider creating a custom View component and drawing with a Canvas in <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">View.onDraw()</a></code></code>. The most convenient aspect of doing so is that the Android framework will provide you with a pre-defined Canvas to which you will place your drawing calls.</p> 
 <p>To start, extend the <code><a href="../../../reference/android/view/View.html">View</a></code> class (or descendant thereof) and define the <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code></code> callback method. This method will be called by the Android framework to request that your View draw itself. This is where you will perform all your calls to draw through the <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code>, which is passed to you through the <code>onDraw()</code> callback.</p> 
 <p>The Android framework will only call <code>onDraw()</code> as necessary. Each time that your application is prepared to be drawn, you must request your View be invalidated by calling <code><code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code></code>. This indicates that you'd like your View to be drawn and Android will then call your <code>onDraw()</code> method (though is not guaranteed that the callback will be instantaneous). </p> 
 <p>Inside your View component's <code>onDraw()</code>, use the Canvas given to you for all your drawing, using various <code>Canvas.draw...()</code> methods, or other class <code>draw()</code> methods that take your Canvas as an argument. Once your <code>onDraw()</code> is complete, the Android framework will use your Canvas to draw a Bitmap handled by the system.</p> 
 <p class="note"><strong>Note: </strong> In order to request an invalidate from a thread other than your main Activity's thread, you must call <code><code><a href="../../../reference/android/view/View.html#postInvalidate()">postInvalidate()</a></code></code>.</p> 
 <p>For information about extending the <code><a href="../../../reference/android/view/View.html">View</a></code> class, read <a href="../../../guide/topics/ui/custom-components.html">Building Custom Components</a>.</p> 
 <p>For a sample application, see the Snake game, in the SDK samples folder: <code>&lt;your-sdk-directory&gt;/samples/Snake/</code>.</p> 
 ","View","android.view.View","class",1
,"Canvas and Drawables","Shape Drawable","<h2 id="shape-drawable">Shape Drawable</h2> 
 <p>When you want to dynamically draw some two-dimensional graphics, a <code><a href="../../../reference/android/graphics/drawable/ShapeDrawable.html">ShapeDrawable</a></code> object will probably suit your needs. With a ShapeDrawable, you can programmatically draw primitive shapes and style them in any way imaginable.</p> 
 <p>A ShapeDrawable is an extension of <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code>, so you can use one where ever a Drawable is expected ¡ª perhaps for the background of a View, set with <code><a href="../../../reference/android/view/View.html#setBackgroundDrawable(android.graphics.drawable.Drawable)">setBackgroundDrawable()</a></code>. Of course, you can also draw your shape as its own custom <code><a href="../../../reference/android/view/View.html">View</a></code>, to be added to your layout however you please. Because the ShapeDrawable has its own <code>draw()</code> method, you can create a subclass of View that draws the ShapeDrawable during the <code>View.onDraw()</code> method. Here's a basic extension of the View class that does just this, to draw a ShapeDrawable as a View:</p> 
 <pre>
      public class CustomDrawableView extends View {
      private ShapeDrawable mDrawable;

      public CustomDrawableView(Context context) {
      super(context);

      int x = 10;
      int y = 10;
      int width = 300;
      int height = 50;

      mDrawable = new ShapeDrawable(new OvalShape());
      mDrawable.getPaint().setColor(0xff74AC23);
      mDrawable.setBounds(x, y, x + width, y + height);
      }

      protected void onDraw(Canvas canvas) {
      mDrawable.draw(canvas);
      }
      }
    </pre> 
 <p>In the constructor, a ShapeDrawable is defines as an <code><a href="../../../reference/android/graphics/drawable/shapes/OvalShape.html">OvalShape</a></code>. It's then given a color and the bounds of the shape are set. If you do not set the bounds, then the shape will not be drawn, whereas if you don't set the color, it will default to black.</p> 
 <p>With the custom View defined, it can be drawn any way you like. With the sample above, we can draw the shape programmatically in an Activity:</p> 
 <pre>
      CustomDrawableView mCustomDrawableView;

      protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      mCustomDrawableView = new CustomDrawableView(this);

      setContentView(mCustomDrawableView);
      }
    </pre> 
 <p>If you'd like to draw this custom drawable from the XML layout instead of from the Activity, then the CustomDrawable class must override the <code><a href="../../../reference/android/view/View.html#View(android.content.Context, android.util.AttributeSet)">View(Context, AttributeSet)</a></code> constructor, which is called when instantiating a View via inflation from XML. Then add a CustomDrawable element to the XML, like so:</p> 
 <pre>
      &lt;com.example.shapedrawable.CustomDrawableView
      android:layout_width=&quot;fill_parent&quot;
      android:layout_height=&quot;wrap_content&quot;
      /&gt;
  </pre> 
 <p>The ShapeDrawable class (like many other Drawable types in the <code><a href="../../../reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a></code> package) allows you to define various properties of the drawable with public methods. Some properties you might want to adjust include alpha transparency, color filter, dither, opacity and color.</p> 
 <p>You can also define primitive drawable shapes using XML. For more information, see the section about Shape Drawables in the <a href="../../../guide/topics/resources/drawable-resource.html#Shape">Drawable Resources</a> document.</p> 
 <!-- TODO
       ","View","android.view.View","class",0
,"Hardware Acceleration","Hardware Acceleration","<p>Beginning in Android 3.0 (API level 11), the Android 2D rendering pipeline supports hardware acceleration, meaning that all drawing operations that are performed on a <code><a href="../../../reference/android/view/View.html">View</a></code>'s canvas use the GPU. Because of the increased resources required to enable hardware acceleration, your app will consume more RAM.</p> 
 <p>Hardware acceleration is enabled by default if your Target API level is &gt;=14, but can also be explicitly enabled. If your application uses only standard views and <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code>s, turning it on globally should not cause any adverse drawing effects. However, because hardware acceleration is not supported for all of the 2D drawing operations, turning it on might affect some of your custom views or drawing calls. Problems usually manifest themselves as invisible elements, exceptions, or wrongly rendered pixels. To remedy this, Android gives you the option to enable or disable hardware acceleration at multiple levels. See <a href="#controlling">Controlling Hardware Acceleration</a>.</p> 
 <p>If your application performs custom drawing, test your application on actual hardware devices with hardware acceleration turned on to find any problems. The <a href="#drawing-support">Unsupported drawing operations</a> section describes known issues with hardware acceleration and how to work around them.</p> 
 ","View","android.view.View","class",0
,"Hardware Acceleration","Determining if a View is Hardware Accelerated","<h2 id="determining">Determining if a View is Hardware Accelerated</h2> 
 <p>It is sometimes useful for an application to know whether it is currently hardware accelerated, especially for things such as custom views. This is particularly useful if your application does a lot of custom drawing and not all operations are properly supported by the new rendering pipeline.</p> 
 <p>There are two different ways to check whether the application is hardware accelerated:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/view/View.html#isHardwareAccelerated()">View.isHardwareAccelerated()</a></code> returns <code>true</code> if the <code><a href="../../../reference/android/view/View.html">View</a></code> is attached to a hardware accelerated window.</li> 
  <li><code><a href="../../../reference/android/graphics/Canvas.html#isHardwareAccelerated()">Canvas.isHardwareAccelerated()</a></code> returns <code>true</code> if the <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code> is hardware accelerated</li> 
 </ul> 
 <p>If you must do this check in your drawing code, use <code><a href="../../../reference/android/graphics/Canvas.html#isHardwareAccelerated()">Canvas.isHardwareAccelerated()</a></code> instead of <code><a href="../../../reference/android/view/View.html#isHardwareAccelerated()">View.isHardwareAccelerated()</a></code> when possible. When a view is attached to a hardware accelerated window, it can still be drawn using a non-hardware accelerated Canvas. This happens, for instance, when drawing a view into a bitmap for caching purposes.</p> 
 ","View","android.view.View","class",1
,"Android Drawing Models","Software-based drawing model","<h3 id="software-model">Software-based drawing model</h3> 
 <p>In the software drawing model, views are drawn with the following two steps:</p> 
 <ol> 
  <li>Invalidate the hierarchy</li> 
  <li>Draw the hierarchy</li> 
 </ol> 
 <p>Whenever an application needs to update a part of its UI, it invokes <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> (or one of its variants) on any view that has changed content. The invalidation messages are propagated all the way up the view hierarchy to compute the regions of the screen that need to be redrawn (the dirty region). The Android system then draws any view in the hierarchy that intersects with the dirty region. Unfortunately, there are two drawbacks to this drawing model:</p> 
 <ul> 
  <li>First, this model requires execution of a lot of code on every draw pass. For example, if your application calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> on a button and that button sits on top of another view, the Android system redraws the view even though it hasn't changed.</li> 
  <li>The second issue is that the drawing model can hide bugs in your application. Since the Android system redraws views when they intersect the dirty region, a view whose content you changed might be redrawn even though <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> was not called on it. When this happens, you are relying on another view being invalidated to obtain the proper behavior. This behavior can change every time you modify your application. Because of this, you should always call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> on your custom views whenever you modify data or state that affects the view¡¯s drawing code.</li> 
 </ul> 
 <p class="note"><strong>Note</strong>: Android views automatically call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> when their properties change, such as the background color or the text in a <code><a href="../../../reference/android/widget/TextView.html">TextView</a></code>.</p> 
 ","View","android.view.View","class",1
,"Android Drawing Models","Hardware accelerated drawing model","<h3 id="hardware-model">Hardware accelerated drawing model</h3> 
 <p>The Android system still uses <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> and <code><a href="../../../reference/android/view/View.html#draw(android.graphics.Canvas)">draw()</a></code> to request screen updates and to render views, but handles the actual drawing differently. Instead of executing the drawing commands immediately, the Android system records them inside display lists, which contain the output of the view hierarchy¡¯s drawing code. Another optimization is that the Android system only needs to record and update display lists for views marked dirty by an <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> call. Views that have not been invalidated can be redrawn simply by re-issuing the previously recorded display list. The new drawing model contains three stages:</p> 
 <ol> 
  <li>Invalidate the hierarchy</li> 
  <li>Record and update display lists</li> 
  <li>Draw the display lists</li> 
 </ol> 
 <p>With this model, you cannot rely on a view intersecting the dirty region to have its <code><a href="../../../reference/android/view/View.html#draw(android.graphics.Canvas)">draw()</a></code> method executed. To ensure that the Android system records a view¡¯s display list, you must call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code>. Forgetting to do so causes a view to look the same even after it has been changed.</p> 
 <p>Using display lists also benefits animation performance because setting specific properties, such as alpha or rotation, does not require invalidating the targeted view (it is done automatically). This optimization also applies to views with display lists (any view when your application is hardware accelerated.) For example, assume there is a <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code> that contains a <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code> above a <code><a href="../../../reference/android/widget/Button.html">Button</a></code>. The display list for the <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code> looks like this:</p> 
 <ul> 
  <li>DrawDisplayList(ListView)</li> 
  <li>DrawDisplayList(Button)</li> 
 </ul> 
 <p>Assume now that you want to change the <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code>'s opacity. After invoking <code>setAlpha(0.5f)</code> on the <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code>, the display list now contains this:</p> 
 <ul> 
  <li>SaveLayerAlpha(0.5)</li> 
  <li>DrawDisplayList(ListView)</li> 
  <li>Restore</li> 
  <li>DrawDisplayList(Button)</li> 
 </ul> 
 <p>The complex drawing code of <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code> was not executed. Instead, the system only updated the display list of the much simpler <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code>. In an application without hardware acceleration enabled, the drawing code of both the list and its parent are executed again.</p> 
 ","View","android.view.View","class",0
,"Hardware Acceleration","View Layers","<h2 id="layers">View Layers</h2> 
 <p>In all versions of Android, views have had the ability to render into off-screen buffers, either by using a view's drawing cache, or by using <code><a href="../../../reference/android/graphics/Canvas.html#saveLayer(android.graphics.RectF, android.graphics.Paint, int)">Canvas.saveLayer()</a></code>. Off-screen buffers, or layers, have several uses. You can use them to get better performance when animating complex views or to apply composition effects. For instance, you can implement fade effects using <code>Canvas.saveLayer()</code> to temporarily render a view into a layer and then composite it back on screen with an opacity factor.</p> 
 <p>Beginning in Android 3.0 (API level 11), you have more control on how and when to use layers with the <code><a href="../../../reference/android/view/View.html#setLayerType(int, android.graphics.Paint)">View.setLayerType()</a></code> method. This API takes two parameters: the type of layer you want to use and an optional <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> object that describes how the layer should be composited. You can use the <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> parameter to apply color filters, special blending modes, or opacity to a layer. A view can use one of three layer types:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_NONE">LAYER_TYPE_NONE</a></code>: The view is rendered normally and is not backed by an off-screen buffer. This is the default behavior.</li> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_HARDWARE">LAYER_TYPE_HARDWARE</a></code>: The view is rendered in hardware into a hardware texture if the application is hardware accelerated. If the application is not hardware accelerated, this layer type behaves the same as <code><a href="../../../reference/android/view/View.html#LAYER_TYPE_SOFTWARE">LAYER_TYPE_SOFTWARE</a></code>.</li> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_SOFTWARE">LAYER_TYPE_SOFTWARE</a></code>: The view is rendered in software into a bitmap.</li> 
 </ul> 
 <p>The type of layer you use depends on your goal:</p> 
 <ul> 
  <li><strong>Performance</strong>: Use a hardware layer type to render a view into a hardware texture. Once a view is rendered into a layer, its drawing code does not have to be executed until the view calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code>. Some animations, such as alpha animations, can then be applied directly onto the layer, which is very efficient for the GPU to do.</li> 
  <li><strong>Visual effects</strong>: Use a hardware or software layer type and a <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> to apply special visual treatments to a view. For instance, you can draw a view in black and white using a <code><a href="../../../reference/android/graphics/ColorMatrixColorFilter.html">ColorMatrixColorFilter</a></code>.</li> 
  <li><strong>Compatibility</strong>: Use a software layer type to force a view to be rendered in software. If a view that is hardware accelerated (for instance, if your whole application is hardware acclerated), is having rendering problems, this is an easy way to work around limitations of the hardware rendering pipeline.</li> 
 </ul> 
 ","View","android.view.View","class",1
,"View Layers","View layers and animations","<h3 id="layers-anims">View layers and animations</h3> 
 <p>Hardware layers can deliver faster and smoother animations when your application is hardware accelerated. Running an animation at 60 frames per second is not always possible when animating complex views that issue a lot of drawing operations. This can be alleviated by using hardware layers to render the view to a hardware texture. The hardware texture can then be used to animate the view, eliminating the need for the view to constantly redraw itself when it is being animated. The view is not redrawn unless you change the view's properties, which calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code>, or if you call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> manually. If you are running an animation in your application and do not obtain the smooth results you want, consider enabling hardware layers on your animated views.</p> 
 <p>When a view is backed by a hardware layer, some of its properties are handled by the way the layer is composited on screen. Setting these properties will be efficient because they do not require the view to be invalidated and redrawn. The following list of properties affect the way the layer is composited. Calling the setter for any of these properties results in optimal invalidation and no redrawing of the targeted view:</p> 
 <ul> 
  <li><code>alpha</code>: Changes the layer's opacity</li> 
  <li><code>x</code>, <code>y</code>, <code>translationX</code>, <code>translationY</code>: Changes the layer's position</li> 
  <li><code>scaleX</code>, <code>scaleY</code>: Changes the layer's size</li> 
  <li><code>rotation</code>, <code>rotationX</code>, <code>rotationY</code>: Changes the layer's orientation in 3D space</li> 
  <li><code>pivotX</code>, <code>pivotY</code>: Changes the layer's transformations origin</li> 
 </ul> 
 <p>These properties are the names used when animating a view with an <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>. If you want to access these properties, call the appropriate setter or getter. For instance, to modify the alpha property, call <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code>. The following code snippet shows the most efficient way to rotate a viewiew in 3D around the Y-axis:</p> 
 <pre>
view.setLayerType(View.LAYER_TYPE_HARDWARE, null);
ObjectAnimator.ofFloat(view, &quot;rotationY&quot;, 180).start();
</pre> 
 <p>Because hardware layers consume video memory, it is highly recommended that you enable them only for the duration of the animation and then disable them after the animation is done. You can accomplish this using animation listeners:</p> 
 <pre>
View.setLayerType(View.LAYER_TYPE_HARDWARE, null);
ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;rotationY&quot;, 180);
animator.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator animation) {
        view.setLayerType(View.LAYER_TYPE_NONE, null);
    }
});
animator.start();
</pre> 
 <p>For more information on property animation, see <a href="../../../guide/topics/graphics/prop-animation.html">Property Animation</a>.</p> 
 ","View","android.view.View","class",0
,"Hardware Acceleration","Tips and Tricks","<h2 id="tips">Tips and Tricks</h2> 
 <p>Switching to hardware accelerated 2D graphics can instantly increase performance, but you should still design your application to use the GPU effectively by following these recommendations:</p> 
 <dl> 
  <dt>
   <strong>Reduce the number of views in your application</strong>
  </dt> 
  <dd>
   The more views the system has to draw, the slower it will be. This applies to the software rendering pipeline as well. Reducing views is one of the easiest ways to optimize your UI.
  </dd> 
  <dt>
   <strong>Avoid overdraw</strong>
  </dt> 
  <dd>
   Do not draw too many layers on top of each other. Remove any views that are completely obscured by other opaque views on top of it. If you need to draw several layers blended on top of each other, consider merging them into a single layer. A good rule of thumb with current hardware is to not draw more than 2.5 times the number of pixels on screen per frame (transparent pixels in a bitmap count!).
  </dd> 
  <dt>
   <strong>Don't create render objects in draw methods</strong>
  </dt> 
  <dd>
   A common mistake is to create a new 
   <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> or a new 
   <code><a href="../../../reference/android/graphics/Path.html">Path</a></code> every time a rendering method is invoked. This forces the garbage collector to run more often and also bypasses caches and optimizations in the hardware pipeline.
  </dd> 
  <dt>
   <strong>Don't modify shapes too often</strong>
  </dt> 
  <dd>
   Complex shapes, paths, and circles for instance, are rendered using texture masks. Every time you create or modify a path, the hardware pipeline creates a new mask, which can be expensive.
  </dd> 
  <dt>
   <strong>Don't modify bitmaps too often</strong>
  </dt> 
  <dd>
   Every time you change the content of a bitmap, it is uploaded again as a GPU texture the next time you draw it.
  </dd> 
  <dt>
   <strong>Use alpha with care</strong>
  </dt> 
  <dd>
   When you make a view translucent using 
   <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code>, 
   <code><a href="../../../reference/android/view/animation/AlphaAnimation.html">AlphaAnimation</a></code>, or 
   <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, it is rendered in an off-screen buffer which doubles the required fill-rate. When applying alpha on very large views, consider setting the view's layer type to 
   <code>LAYER_TYPE_HARDWARE</code>.
  </dd> 
 </dl> 
</div> 
","View","android.view.View","class",0
,"OpenGL ES","The Basics","<h2 id="basics">The Basics</h2> 
 <p>Android supports OpenGL both through its framework API and the Native Development Kit (NDK). This topic focuses on the Android framework interfaces. For more information about the NDK, see the <a href="../../../tools/sdk/ndk/index.html">Android NDK</a>. </p>
 <p>There are two foundational classes in the Android framework that let you create and manipulate graphics with the OpenGL ES API: <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>. If your goal is to use OpenGL in your Android application, understanding how to implement these classes in an activity should be your first objective. </p> 
 <dl> 
  <dt>
   <strong><code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code></strong>
  </dt> 
  <dd>
   This class is a 
   <code><a href="../../../reference/android/view/View.html">View</a></code> where you can draw and manipulate objects using OpenGL API calls and is similar in function to a 
   <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code>. You can use this class by creating an instance of 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and adding your 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">Renderer</a></code> to it. However, if you want to capture touch screen events, you should extend the 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> class to implement the touch listeners, as shown in OpenGL training lesson, 
   <a href="../../../training/graphics/opengl/touch.html">Responding to Touch Events</a>.
  </dd> 
  <dt>
   <strong><code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code></strong>
  </dt> 
  <dd>
   This interface defines the methods required for drawing graphics in a 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. You must provide an implementation of this interface as a separate class and attach it to your 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> instance using 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html#setRenderer(android.opengl.GLSurfaceView.Renderer)">GLSurfaceView.setRenderer()</a></code>. 
   <p>The <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> interface requires that you implement the following methods:</p> 
   <ul> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceCreated(javax.microedition.khronos.opengles.GL10, javax.microedition.khronos.egl.EGLConfig)">onSurfaceCreated()</a></code>: The system calls this method once, when creating the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. Use this method to perform actions that need to happen only once, such as setting OpenGL environment parameters or initializing OpenGL graphic objects. </li> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onDrawFrame(javax.microedition.khronos.opengles.GL10)">onDrawFrame()</a></code>: The system calls this method on each redraw of the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. Use this method as the primary execution point for drawing (and re-drawing) graphic objects.</li> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)">onSurfaceChanged()</a></code>: The system calls this method when the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> geometry changes, including changes in size of the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> or orientation of the device screen. For example, the system calls this method when the device changes from portrait to landscape orientation. Use this method to respond to changes in the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> container. </li> 
   </ul> 
  </dd> 
 </dl> 
 ","View","android.view.View","class",1
,"Property Animation","How Property Animation Differs from View Animation","<h2 id="property-vs-view">How Property Animation Differs from View Animation</h2> 
 <p>The view animation system provides the capability to only animate <code><a href="../../../reference/android/view/View.html">View</a></code> objects, so if you wanted to animate non-<code><a href="../../../reference/android/view/View.html">View</a></code> objects, you have to implement your own code to do so. The view animation system is also constrained in the fact that it only exposes a few aspects of a <code><a href="../../../reference/android/view/View.html">View</a></code> object to animate, such as the scaling and rotation of a View but not the background color, for instance.</p> 
 <p>Another disadvantage of the view animation system is that it only modified where the View was drawn, and not the actual View itself. For instance, if you animated a button to move across the screen, the button draws correctly, but the actual location where you can click the button does not change, so you have to implement your own logic to handle this.</p> 
 <p>With the property animation system, these constraints are completely removed, and you can animate any property of any object (Views and non-Views) and the object itself is actually modified. The property animation system is also more robust in the way it carries out animation. At a high level, you assign animators to the properties that you want to animate, such as color, position, or size and can define aspects of the animation such as interpolation and synchronization of multiple animators.</p> 
 <p>The view animation system, however, takes less time to setup and requires less code to write. If view animation accomplishes everything that you need to do, or if your existing code already works the way you want, there is no need to use the property animation system. It also might make sense to use both animation systems for different situations if the use case arises.</p> 
 ","View","android.view.View","class",1
,"Property Animation","Animating with ObjectAnimator","<h2 id="object-animator">Animating with ObjectAnimator</h2> 
 <p>The <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> is a subclass of the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> (discussed in the previous section) and combines the timing engine and value computation of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> with the ability to animate a named property of a target object. This makes animating any object much easier, as you no longer need to implement the <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html">ValueAnimator.AnimatorUpdateListener</a></code>, because the animated property updates automatically.</p> 
 <p>Instantiating an <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> is similar to a <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>, but you also specify the object and the name of that object's property (as a String) along with the values to animate between:</p> 
 <pre>
ObjectAnimator anim = ObjectAnimator.ofFloat(foo, &quot;alpha&quot;, 0f, 1f);
anim.setDuration(1000);
anim.start();
</pre> 
 <p>To have the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> update properties correctly, you must do the following:</p> 
 <ul> 
  <li>The object property that you are animating must have a setter function (in camel case) in the form of <code>set&lt;propertyName&gt;()</code>. Because the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> automatically updates the property during animation, it must be able to access the property with this setter method. For example, if the property name is <code>foo</code>, you need to have a <code>setFoo()</code> method. If this setter method does not exist, you have three options: 
   <ul> 
    <li>Add the setter method to the class if you have the rights to do so.</li> 
    <li>Use a wrapper class that you have rights to change and have that wrapper receive the value with a valid setter method and forward it to the original object.</li> 
    <li>Use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> instead.</li> 
   </ul> </li> 
  <li>If you specify only one value for the <code>values...</code> parameter in one of the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> factory methods, it is assumed to be the ending value of the animation. Therefore, the object property that you are animating must have a getter function that is used to obtain the starting value of the animation. The getter function must be in the form of <code>get&lt;propertyName&gt;()</code>. For example, if the property name is <code>foo</code>, you need to have a <code>getFoo()</code> method.</li> 
  <li>The getter (if needed) and setter methods of the property that you are animating must operate on the same type as the starting and ending values that you specify to <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>. For example, you must have <code>targetObject.setPropName(float)</code> and <code>targetObject.getPropName(float)</code> if you construct the following <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>: <pre>
ObjectAnimator.ofFloat(targetObject, &quot;propName&quot;, 1f)
</pre> </li> 
  <li>Depending on what property or object you are animating, you might need to call the <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> method on a View to force the screen to redraw itself with the updated animated values. You do this in the <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> callback. For example, animating the color property of a Drawable object only cause updates to the screen when that object redraws itself. All of the property setters on View, such as <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code> and <code><a href="../../../reference/android/view/View.html#setTranslationX(float)">setTranslationX()</a></code> invalidate the View properly, so you do not need to invalidate the View when calling these methods with new values. For more information on listeners, see the section about <a href="#listeners">Animation Listeners</a>. </li> 
 </ul> 
 ","View","android.view.View","class",0
,"Property Animation","Animation Listeners","<h2 id="listeners">Animation Listeners</h2> 
 <p> You can listen for important events during an animation's duration with the listeners described below. </p> 
 <ul> 
  <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> 
   <ul> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationStart(android.animation.Animator)">onAnimationStart()</a></code> - Called when the animation starts.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code> - Called when the animation ends.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationRepeat(android.animation.Animator)">onAnimationRepeat()</a></code> - Called when the animation repeats itself.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationCancel(android.animation.Animator)">onAnimationCancel()</a></code> - Called when the animation is canceled. A cancelled animation also calls <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code>, regardless of how they were ended.</li> 
   </ul> </li> 
  <li><code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html">ValueAnimator.AnimatorUpdateListener</a></code> 
   <ul> 
    <li> <p><code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> - called on every frame of the animation. Listen to this event to use the calculated values generated by <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> during an animation. To use the value, query the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> object passed into the event to get the current animated value with the <code><a href="../../../reference/android/animation/ValueAnimator.html#getAnimatedValue()">getAnimatedValue()</a></code> method. Implementing this listener is required if you use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>. </p> <p> Depending on what property or object you are animating, you might need to call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> on a View to force that area of the screen to redraw itself with the new animated values. For example, animating the color property of a Drawable object only cause updates to the screen when that object redraws itself. All of the property setters on View, such as <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code> and <code><a href="../../../reference/android/view/View.html#setTranslationX(float)">setTranslationX()</a></code> invalidate the View properly, so you do not need to invalidate the View when calling these methods with new values. </p> </li> 
   </ul> </li> 
 </ul> 
 <p>You can extend the <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> class instead of implementing the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> interface, if you do not want to implement all of the methods of the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> interface. The <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> class provides empty implementations of the methods that you can choose to override.</p> 
 <p>For example, the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/BouncingBalls.html">Bouncing Balls</a> sample in the API demos creates an <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> for just the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code> callback:</p> 
 <pre>
ValueAnimatorAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, &quot;alpha&quot;, 1f, 0f);
fadeAnim.setDuration(250);
fadeAnim.addListener(new AnimatorListenerAdapter() {
public void onAnimationEnd(Animator animation) {
    balls.remove(((ObjectAnimator)animation).getTarget());
}
</pre> 
 ","View","android.view.View","class",1
,"Property Animation","Animating Layout Changes to ViewGroups","<h2 id="layout">Animating Layout Changes to ViewGroups</h2> 
 <p>The property animation system provides the capability to animate changes to ViewGroup objects as well as provide an easy way to animate View objects themselves.</p> 
 <p>You can animate layout changes within a ViewGroup with the <code><a href="../../../reference/android/animation/LayoutTransition.html">LayoutTransition</a></code> class. Views inside a ViewGroup can go through an appearing and disappearing animation when you add them to or remove them from a ViewGroup or when you call a View's <code><a href="../../../reference/android/view/View.html#setVisibility(int)">setVisibility()</a></code> method with <code><a href="../../../reference/android/view/View.html#VISIBLE">VISIBLE</a></code>, android.view.View#INVISIBLE}, or <code><a href="../../../reference/android/view/View.html#GONE">GONE</a></code>. The remaining Views in the ViewGroup can also animate into their new positions when you add or remove Views. You can define the following animations in a <code><a href="../../../reference/android/animation/LayoutTransition.html">LayoutTransition</a></code> object by calling <code><a href="../../../reference/android/animation/LayoutTransition.html#setAnimator(int, android.animation.Animator)">setAnimator()</a></code> and passing in an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> object with one of the following <code><a href="../../../reference/android/animation/LayoutTransition.html">LayoutTransition</a></code> constants:</p> 
 <ul> 
  <li><code>APPEARING</code> - A flag indicating the animation that runs on items that are appearing in the container.</li> 
  <li><code>CHANGE_APPEARING</code> - A flag indicating the animation that runs on items that are changing due to a new item appearing in the container.</li> 
  <li><code>DISAPPEARING</code> - A flag indicating the animation that runs on items that are disappearing from the container.</li> 
  <li><code>CHANGE_DISAPPEARING</code> - A flag indicating the animation that runs on items that are changing due to an item disappearing from the container.</li> 
 </ul> 
 <p>You can define your own custom animations for these four types of events to customize the look of your layout transitions or just tell the animation system to use the default animations.</p> 
 <p>The <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/LayoutAnimations.html"> LayoutAnimations</a> sample in API Demos shows you how to define animations for layout transitions and then set the animations on the View objects that you want to animate.</p> 
 <p>The <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/LayoutAnimationsByDefault.html"> LayoutAnimationsByDefault</a> and its corresponding <a href="../../../resources/samples/ApiDemos/res/layout/layout_animations_by_default.html">layout_animations_by_default.xml</a> layout resource file show you how to enable the default layout transitions for ViewGroups in XML. The only thing that you need to do is to set the <code>android:animateLayoutchanges</code> attribute to <code>true</code> for the ViewGroup. For example:</p> 
 <pre>
&lt;LinearLayout
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;match_parent&quot;
    android:id=&quot;@+id/verticalContainer&quot;
    android:animateLayoutChanges=&quot;true&quot; /&gt;
</pre> 
 <p>Setting this attribute to true automatically animates Views that are added or removed from the ViewGroup as well as the remaining Views in the ViewGroup.</p> 
 ","View","android.view.View","class",0
,"Property Animation","Animating Views","<h2 id="views">Animating Views</h2> 
 <p>The property animation system allow streamlined animation of View objects and offers a few advantages over the view animation system. The view animation system transformed View objects by changing the way that they were drawn. This was handled in the container of each View, because the View itself had no properties to manipulate. This resulted in the View being animated, but caused no change in the View object itself. This led to behavior such as an object still existing in its original location, even though it was drawn on a different location on the screen. In Android 3.0, new properties and the corresponding getter and setter methods were added to eliminate this drawback.</p> 
 <p>The property animation system can animate Views on the screen by changing the actual properties in the View objects. In addition, Views also automatically call the <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> method to refresh the screen whenever its properties are changed. The new properties in the <code><a href="../../../reference/android/view/View.html">View</a></code> class that facilitate property animations are:</p> 
 <ul> 
  <li><code>translationX</code> and <code>translationY</code>: These properties control where the View is located as a delta from its left and top coordinates which are set by its layout container.</li> 
  <li><code>rotation</code>, <code>rotationX</code>, and <code>rotationY</code>: These properties control the rotation in 2D (<code>rotation</code> property) and 3D around the pivot point.</li> 
  <li><code>scaleX</code> and <code>scaleY</code>: These properties control the 2D scaling of a View around its pivot point.</li> 
  <li><code>pivotX</code> and <code>pivotY</code>: These properties control the location of the pivot point, around which the rotation and scaling transforms occur. By default, the pivot point is located at the center of the object.</li> 
  <li><code>x</code> and <code>y</code>: These are simple utility properties to describe the final location of the View in its container, as a sum of the left and top values and translationX and translationY values.</li> 
  <li><code>alpha</code>: Represents the alpha transparency on the View. This value is 1 (opaque) by default, with a value of 0 representing full transparency (not visible).</li> 
 </ul> 
 <p>To animate a property of a View object, such as its color or rotation value, all you need to do is create a property animator and specify the View property that you want to animate. For example:</p> 
 <pre>
ObjectAnimator.ofFloat(myView, &quot;rotation&quot;, 0f, 360f);
</pre> 
 <p>For more information on creating animators, see the sections on animating with <a href="#value-animator">ValueAnimator</a> and <a href="#object-animator">ObjectAnimator</a>. </p> 
 ","View","android.view.View","class",1
,"Animating Views","Animating with ViewPropertyAnimator","<h3 id="view-prop-animator">Animating with ViewPropertyAnimator</h3> 
 <p>The <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> provides a simple way to animate several properties of a <code><a href="../../../reference/android/view/View.html">View</a></code> in parallel, using a single underlying <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> object. It behaves much like an <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, because it modifies the actual values of the view's properties, but is more efficient when animating many properties at once. In addition, the code for using the <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> is much more concise and easier to read. The following code snippets show the differences in using multiple <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> objects, a single <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, and the <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> when simultaneously animating the <code>x</code> and <code>y</code> property of a view.</p> 
 <p><strong>Multiple ObjectAnimator objects</strong></p> 
 <pre>
ObjectAnimator animX = ObjectAnimator.ofFloat(myView, &quot;x&quot;, 50f);
ObjectAnimator animY = ObjectAnimator.ofFloat(myView, &quot;y&quot;, 100f);
AnimatorSet animSetXY = new AnimatorSet();
animSetXY.playTogether(animX, animY);
animSetXY.start();
</pre> 
 <p><strong>One ObjectAnimator</strong></p> 
 <pre>
PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(&quot;x&quot;, 50f);
PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(&quot;y&quot;, 100f);
ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();
</pre> 
 <p><strong>ViewPropertyAnimator</strong></p> 
 <pre>
myView.animate().x(50f).y(100f);
</pre> 
 <p> For more detailed information about <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code>, see the corresponding Android Developers <a href="http://android-developers.blogspot.com/2011/05/introducing-viewpropertyanimator.html">blog post</a>.</p> 
 ","View","android.view.View","class",0
,"Canvas and Drawables","Canvas and Drawables","<p>The Android framework APIs provides a set 2D drawing APIs that allow you to render your own custom graphics onto a canvas or to modify existing Views to customize their look and feel. When drawing 2D graphics, you'll typically do so in one of two ways:</p> 
 <ol type="a"> 
  <li>Draw your graphics or animations into a View object from your layout. In this manner, the drawing of your graphics is handled by the system's normal View hierarchy drawing process ¡ª you simply define the graphics to go inside the View.</li> 
  <li>Draw your graphics directly to a Canvas. This way, you personally call the appropriate class's <code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code> method (passing it your Canvas), or one of the Canvas <code>draw...()</code> methods (like <code><code><a href="../../../reference/android/graphics/Canvas.html#drawPicture(android.graphics.Picture, android.graphics.Rect)">drawPicture()</a></code></code>). In doing so, you are also in control of any animation.</li> 
 </ol> 
 <p>Option &quot;a,&quot; drawing to a View, is your best choice when you want to draw simple graphics that do not need to change dynamically and are not part of a performance-intensive game. For example, you should draw your graphics into a View when you want to display a static graphic or predefined animation, within an otherwise static application. Read <a href="#drawables">Drawables</a> for more information. </p> 
 <p>Option &quot;b,&quot; drawing to a Canvas, is better when your application needs to regularly re-draw itself. Applications such as video games should be drawing to the Canvas on its own. However, there's more than one way to do this:</p> 
 <ul> 
  <li>In the same thread as your UI Activity, wherein you create a custom View component in your layout, call <code><code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code></code> and then handle the <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code></code> callback.</li> 
  <li>Or, in a separate thread, wherein you manage a <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code> and perform draws to the Canvas as fast as your thread is capable (you do not need to request <code>invalidate()</code>).</li> 
 </ul> 
 ","Canvas","android.graphics.Canvas","class",1
,"Canvas and Drawables","Draw with a Canvas","<h2 id="draw-with-canvas">Draw with a Canvas</h2> 
 <p>When you're writing an application in which you would like to perform specialized drawing and/or control the animation of graphics, you should do so by drawing through a <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code>. A Canvas works for you as a pretense, or interface, to the actual surface upon which your graphics will be drawn ¡ª it holds all of your &quot;draw&quot; calls. Via the Canvas, your drawing is actually performed upon an underlying <code><a href="../../../reference/android/graphics/Bitmap.html">Bitmap</a></code>, which is placed into the window.</p> 
 <p>In the event that you're drawing within the <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code></code> callback method, the Canvas is provided for you and you need only place your drawing calls upon it. You can also acquire a Canvas from <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">SurfaceHolder.lockCanvas()</a></code></code>, when dealing with a SurfaceView object. (Both of these scenarios are discussed in the following sections.) However, if you need to create a new Canvas, then you must define the <code><a href="../../../reference/android/graphics/Bitmap.html">Bitmap</a></code> upon which drawing will actually be performed. The Bitmap is always required for a Canvas. You can set up a new Canvas like this:</p> 
 <pre>
Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
Canvas c = new Canvas(b);
</pre> 
 <p>Now your Canvas will draw onto the defined Bitmap. After drawing upon it with the Canvas, you can then carry your Bitmap to another Canvas with one of the <code><code><a href="../../../reference/android/graphics/Canvas.html#drawBitmap(android.graphics.Bitmap, android.graphics.Matrix, android.graphics.Paint)">Canvas.drawBitmap(Bitmap,...)</a></code></code> methods. It's recommended that you ultimately draw your final graphics through a Canvas offered to you by <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">View.onDraw()</a></code></code> or <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">SurfaceHolder.lockCanvas()</a></code></code> (see the following sections).</p> 
 <p>The <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code> class has its own set of drawing methods that you can use, like <code>drawBitmap(...)</code>, <code>drawRect(...)</code>, <code>drawText(...)</code>, and many more. Other classes that you might use also have <code>draw()</code> methods. For example, you'll probably have some <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> objects that you want to put on the Canvas. Drawable has its own <code><code><a href="../../../reference/android/graphics/drawable/Drawable.html#draw(android.graphics.Canvas)">draw()</a></code></code> method that takes your Canvas as an argument.</p> 
 ","Canvas","android.graphics.Canvas","class",1
,"Draw with a Canvas","On a View","<h3 id="on-view">On a View</h3> 
 <p>If your application does not require a significant amount of processing or frame-rate speed (perhaps for a chess game, a snake game, or another slowly-animated application), then you should consider creating a custom View component and drawing with a Canvas in <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">View.onDraw()</a></code></code>. The most convenient aspect of doing so is that the Android framework will provide you with a pre-defined Canvas to which you will place your drawing calls.</p> 
 <p>To start, extend the <code><a href="../../../reference/android/view/View.html">View</a></code> class (or descendant thereof) and define the <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code></code> callback method. This method will be called by the Android framework to request that your View draw itself. This is where you will perform all your calls to draw through the <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code>, which is passed to you through the <code>onDraw()</code> callback.</p> 
 <p>The Android framework will only call <code>onDraw()</code> as necessary. Each time that your application is prepared to be drawn, you must request your View be invalidated by calling <code><code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code></code>. This indicates that you'd like your View to be drawn and Android will then call your <code>onDraw()</code> method (though is not guaranteed that the callback will be instantaneous). </p> 
 <p>Inside your View component's <code>onDraw()</code>, use the Canvas given to you for all your drawing, using various <code>Canvas.draw...()</code> methods, or other class <code>draw()</code> methods that take your Canvas as an argument. Once your <code>onDraw()</code> is complete, the Android framework will use your Canvas to draw a Bitmap handled by the system.</p> 
 <p class="note"><strong>Note: </strong> In order to request an invalidate from a thread other than your main Activity's thread, you must call <code><code><a href="../../../reference/android/view/View.html#postInvalidate()">postInvalidate()</a></code></code>.</p> 
 <p>For information about extending the <code><a href="../../../reference/android/view/View.html">View</a></code> class, read <a href="../../../guide/topics/ui/custom-components.html">Building Custom Components</a>.</p> 
 <p>For a sample application, see the Snake game, in the SDK samples folder: <code>&lt;your-sdk-directory&gt;/samples/Snake/</code>.</p> 
 ","Canvas","android.graphics.Canvas","class",1
,"Draw with a Canvas","On a SurfaceView","<h3 id="on-surfaceview">On a SurfaceView</h3> 
 <p>The <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code> is a special subclass of View that offers a dedicated drawing surface within the View hierarchy. The aim is to offer this drawing surface to an application's secondary thread, so that the application isn't required to wait until the system's View hierarchy is ready to draw. Instead, a secondary thread that has reference to a SurfaceView can draw to its own Canvas at its own pace.</p> 
 <p>To begin, you need to create a new class that extends <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code>. The class should also implement <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code>. This subclass is an interface that will notify you with information about the underlying <code><a href="../../../reference/android/view/Surface.html">Surface</a></code>, such as when it is created, changed, or destroyed. These events are important so that you know when you can start drawing, whether you need to make adjustments based on new surface properties, and when to stop drawing and potentially kill some tasks. Inside your SurfaceView class is also a good place to define your secondary Thread class, which will perform all the drawing procedures to your Canvas.</p> 
 <p>Instead of handling the Surface object directly, you should handle it via a <code><a href="../../../reference/android/view/SurfaceHolder.html">SurfaceHolder</a></code>. So, when your SurfaceView is initialized, get the SurfaceHolder by calling <code><code><a href="../../../reference/android/view/SurfaceView.html#getHolder()">getHolder()</a></code></code>. You should then notify the SurfaceHolder that you'd like to receive SurfaceHolder callbacks (from <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code>) by calling <code><a href="../../../reference/android/view/SurfaceHolder.html#addCallback(android.view.SurfaceHolder.Callback)">addCallback()</a></code> (pass it <var>this</var>). Then override each of the <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code> methods inside your SurfaceView class.</p> 
 <p>In order to draw to the Surface Canvas from within your second thread, you must pass the thread your SurfaceHandler and retrieve the Canvas with <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">lockCanvas()</a></code></code>. You can now take the Canvas given to you by the SurfaceHolder and do your necessary drawing upon it. Once you're done drawing with the Canvas, call <code><code><a href="../../../reference/android/view/SurfaceHolder.html#unlockCanvasAndPost(android.graphics.Canvas)">unlockCanvasAndPost()</a></code></code>, passing it your Canvas object. The Surface will now draw the Canvas as you left it. Perform this sequence of locking and unlocking the canvas each time you want to redraw.</p> 
 <p class="note"><strong>Note:</strong> On each pass you retrieve the Canvas from the SurfaceHolder, the previous state of the Canvas will be retained. In order to properly animate your graphics, you must re-paint the entire surface. For example, you can clear the previous state of the Canvas by filling in a color with <code><code><a href="../../../reference/android/graphics/Canvas.html#drawColor(int)">drawColor()</a></code></code> or setting a background image with <code><code><a href="../../../reference/android/graphics/Canvas.html#drawBitmap(android.graphics.Bitmap, android.graphics.Rect, android.graphics.RectF, android.graphics.Paint)">drawBitmap()</a></code></code>. Otherwise, you will see traces of the drawings you previously performed.</p> 
 <p>For a sample application, see the Lunar Lander game, in the SDK samples folder: <code>&lt;your-sdk-directory&gt;/samples/LunarLander/</code>. Or, browse the source in the <a href="../../../guide/samples/index.html">Sample Code</a> section.</p> 
 ","Canvas","android.graphics.Canvas","class",1
,"Hardware Acceleration","Determining if a View is Hardware Accelerated","<h2 id="determining">Determining if a View is Hardware Accelerated</h2> 
 <p>It is sometimes useful for an application to know whether it is currently hardware accelerated, especially for things such as custom views. This is particularly useful if your application does a lot of custom drawing and not all operations are properly supported by the new rendering pipeline.</p> 
 <p>There are two different ways to check whether the application is hardware accelerated:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/view/View.html#isHardwareAccelerated()">View.isHardwareAccelerated()</a></code> returns <code>true</code> if the <code><a href="../../../reference/android/view/View.html">View</a></code> is attached to a hardware accelerated window.</li> 
  <li><code><a href="../../../reference/android/graphics/Canvas.html#isHardwareAccelerated()">Canvas.isHardwareAccelerated()</a></code> returns <code>true</code> if the <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code> is hardware accelerated</li> 
 </ul> 
 <p>If you must do this check in your drawing code, use <code><a href="../../../reference/android/graphics/Canvas.html#isHardwareAccelerated()">Canvas.isHardwareAccelerated()</a></code> instead of <code><a href="../../../reference/android/view/View.html#isHardwareAccelerated()">View.isHardwareAccelerated()</a></code> when possible. When a view is attached to a hardware accelerated window, it can still be drawn using a non-hardware accelerated Canvas. This happens, for instance, when drawing a view into a bitmap for caching purposes.</p> 
 ","Canvas","android.graphics.Canvas","class",1
,"Hardware Acceleration","Unsupported Drawing Operations","<h2 id="unsupported">Unsupported Drawing Operations</h2> 
 <p>When hardware accelerated, the 2D rendering pipeline supports the most commonly used <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code> drawing operations as well as many less-used operations. All of the drawing operations that are used to render applications that ship with Android, default widgets and layouts, and common advanced visual effects such as reflections and tiled textures are supported.</p> 
 <p>The following table describes the support level of various operations across API levels:</p> 
 <style type="text/css">
    .tblGenFixed, .tblGeneric{font-size:15px}.tblGenFixed td {padding:0 3px;letter-spacing:0;word-spacing:0;background-color:#fff;z-index:1;border-top:0px none;border-left:0px none;border-bottom:1px solid #CCC;border-right:1px solid #CCC;} .dn {display:none} .tblGenFixed td.s0 {background-color:white;border-top:1px solid #CCC;border-left:1px solid #CCC;} .tblGenFixed td.s1 {background-color:#434343;color:#ffffff;text-align:center;border-top:1px solid #CCC;} .tblGenFixed td.s2 {background-color:#d9d9d9;color:#000000;text-align:center;} .tblGenFixed td.s3 {background-color:white;color:#000000;text-align:center;} .tblGenFixed td.s5 {background-color:#434343;color:#ffffff;text-align:left;border-left:1px solid #CCC;} .tblGenFixed td.s10 {background-color:white;font-family:courier new,monospace;color:#000000;text-align:right;border-left:1px solid #CCC;} .tblGenFixed td.g_pos {background-color:#d9d9d9;color:#6aa84f;text-align:center;} .tblGenFixed td.g_neg {background-color:#d9d9d9;color:#980000;text-align:center;} .tblGenFixed td.w_pos {background-color:white;color:#6aa84f;text-align:center;} .tblGenFixed td.w_neg {background-color:white;color:#980000;text-align:center;}
  </style> 
 <table border="0" cellpadding="0" cellspacing="0" class="tblGenFixed" id="tblMain"> 
  <tbody> 
   <tr class="rShim"> 
    <td class="rShim" style="width:380px;"></td> 
    <td class="rShim" style="width:120px;"></td> 
    <td class="rShim" style="width:120px;"></td> 
    <td class="rShim" style="width:120px;"></td> 
    <td class="rShim" style="width:120px;"></td> 
   </tr> 
   <tr> 
    <td rowspan="2" class="s0"></td> 
    <td colspan="4" class="s1">API level</td> 
   </tr> 
   <tr> 
    <td style="display:none;"></td> 
    <td class="s2">&lt; 16</td> 
    <td class="s3">16</td> 
    <td class="s2">17</td> 
    <td class="s3">18</td> 
   </tr> 
   <tr> 
    <td colspan="5" class="s5">Canvas</td> 
   </tr> 
   <tr> 
    <td class="s10">drawBitmapMesh() (colors array)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">drawPicture()</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">drawPosText()</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
    <td class="g_pos">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">drawTextOnPath()</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
    <td class="g_pos">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">drawVertices()</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">setDrawFilter()</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
    <td class="g_pos">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">clipPath()</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">clipRegion()</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">clipRect(Region.Op.XOR)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">clipRect(Region.Op.Difference)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">clipRect(Region.Op.ReverseDifference)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">clipRect() with rotation/perspective</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td colspan="5" class="s5">Paint</td> 
   </tr> 
   <tr> 
    <td class="s10">setAntiAlias() (for text)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">setAntiAlias() (for lines)</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
    <td class="g_pos">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">setFilterBitmap()</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_pos">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">setLinearText()</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">setMaskFilter()</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">setPathEffect() (for lines)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">setRasterizer()</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">setShadowLayer() (other than text)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">setStrokeCap() (for lines)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
   <tr> 
    <td class="s10">setStrokeCap() (for points)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">setSubpixelText()</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td colspan="5" class="s5">Xfermode</td> 
   </tr> 
   <tr> 
    <td class="s10">AvoidXfermode</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">PixelXorXfermode</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">PorterDuff.Mode.DARKEN (framebuffer)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">PorterDuff.Mode.LIGHTEN (framebuffer)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">PorterDuff.Mode.OVERLAY (framebuffer)</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td colspan="5" class="s5">Shader</td> 
   </tr> 
   <tr> 
    <td class="s10">ComposeShader inside ComposeShader</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">Same type shaders inside ComposeShader</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
   </tr> 
   <tr> 
    <td class="s10">Local matrix on ComposeShader</td> 
    <td class="g_neg">?</td> 
    <td class="w_neg">?</td> 
    <td class="g_neg">?</td> 
    <td class="w_pos">?</td> 
   </tr> 
  </tbody> 
 </table> 
 ","Canvas","android.graphics.Canvas","class",0
,"Hardware Acceleration","View Layers","<h2 id="layers">View Layers</h2> 
 <p>In all versions of Android, views have had the ability to render into off-screen buffers, either by using a view's drawing cache, or by using <code><a href="../../../reference/android/graphics/Canvas.html#saveLayer(android.graphics.RectF, android.graphics.Paint, int)">Canvas.saveLayer()</a></code>. Off-screen buffers, or layers, have several uses. You can use them to get better performance when animating complex views or to apply composition effects. For instance, you can implement fade effects using <code>Canvas.saveLayer()</code> to temporarily render a view into a layer and then composite it back on screen with an opacity factor.</p> 
 <p>Beginning in Android 3.0 (API level 11), you have more control on how and when to use layers with the <code><a href="../../../reference/android/view/View.html#setLayerType(int, android.graphics.Paint)">View.setLayerType()</a></code> method. This API takes two parameters: the type of layer you want to use and an optional <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> object that describes how the layer should be composited. You can use the <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> parameter to apply color filters, special blending modes, or opacity to a layer. A view can use one of three layer types:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_NONE">LAYER_TYPE_NONE</a></code>: The view is rendered normally and is not backed by an off-screen buffer. This is the default behavior.</li> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_HARDWARE">LAYER_TYPE_HARDWARE</a></code>: The view is rendered in hardware into a hardware texture if the application is hardware accelerated. If the application is not hardware accelerated, this layer type behaves the same as <code><a href="../../../reference/android/view/View.html#LAYER_TYPE_SOFTWARE">LAYER_TYPE_SOFTWARE</a></code>.</li> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_SOFTWARE">LAYER_TYPE_SOFTWARE</a></code>: The view is rendered in software into a bitmap.</li> 
 </ul> 
 <p>The type of layer you use depends on your goal:</p> 
 <ul> 
  <li><strong>Performance</strong>: Use a hardware layer type to render a view into a hardware texture. Once a view is rendered into a layer, its drawing code does not have to be executed until the view calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code>. Some animations, such as alpha animations, can then be applied directly onto the layer, which is very efficient for the GPU to do.</li> 
  <li><strong>Visual effects</strong>: Use a hardware or software layer type and a <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> to apply special visual treatments to a view. For instance, you can draw a view in black and white using a <code><a href="../../../reference/android/graphics/ColorMatrixColorFilter.html">ColorMatrixColorFilter</a></code>.</li> 
  <li><strong>Compatibility</strong>: Use a software layer type to force a view to be rendered in software. If a view that is hardware accelerated (for instance, if your whole application is hardware acclerated), is having rendering problems, this is an easy way to work around limitations of the hardware rendering pipeline.</li> 
 </ul> 
 ","Canvas","android.graphics.Canvas","class",0
,"Canvas and Drawables","Draw with a Canvas","<h2 id="draw-with-canvas">Draw with a Canvas</h2> 
 <p>When you're writing an application in which you would like to perform specialized drawing and/or control the animation of graphics, you should do so by drawing through a <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code>. A Canvas works for you as a pretense, or interface, to the actual surface upon which your graphics will be drawn ¡ª it holds all of your &quot;draw&quot; calls. Via the Canvas, your drawing is actually performed upon an underlying <code><a href="../../../reference/android/graphics/Bitmap.html">Bitmap</a></code>, which is placed into the window.</p> 
 <p>In the event that you're drawing within the <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code></code> callback method, the Canvas is provided for you and you need only place your drawing calls upon it. You can also acquire a Canvas from <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">SurfaceHolder.lockCanvas()</a></code></code>, when dealing with a SurfaceView object. (Both of these scenarios are discussed in the following sections.) However, if you need to create a new Canvas, then you must define the <code><a href="../../../reference/android/graphics/Bitmap.html">Bitmap</a></code> upon which drawing will actually be performed. The Bitmap is always required for a Canvas. You can set up a new Canvas like this:</p> 
 <pre>
Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
Canvas c = new Canvas(b);
</pre> 
 <p>Now your Canvas will draw onto the defined Bitmap. After drawing upon it with the Canvas, you can then carry your Bitmap to another Canvas with one of the <code><code><a href="../../../reference/android/graphics/Canvas.html#drawBitmap(android.graphics.Bitmap, android.graphics.Matrix, android.graphics.Paint)">Canvas.drawBitmap(Bitmap,...)</a></code></code> methods. It's recommended that you ultimately draw your final graphics through a Canvas offered to you by <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">View.onDraw()</a></code></code> or <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">SurfaceHolder.lockCanvas()</a></code></code> (see the following sections).</p> 
 <p>The <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code> class has its own set of drawing methods that you can use, like <code>drawBitmap(...)</code>, <code>drawRect(...)</code>, <code>drawText(...)</code>, and many more. Other classes that you might use also have <code>draw()</code> methods. For example, you'll probably have some <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> objects that you want to put on the Canvas. Drawable has its own <code><code><a href="../../../reference/android/graphics/drawable/Drawable.html#draw(android.graphics.Canvas)">draw()</a></code></code> method that takes your Canvas as an argument.</p> 
 ","Bitmap","android.graphics.Bitmap","class",1
,"Canvas and Drawables","Draw with a Canvas","<h2 id="draw-with-canvas">Draw with a Canvas</h2> 
 <p>When you're writing an application in which you would like to perform specialized drawing and/or control the animation of graphics, you should do so by drawing through a <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code>. A Canvas works for you as a pretense, or interface, to the actual surface upon which your graphics will be drawn ¡ª it holds all of your &quot;draw&quot; calls. Via the Canvas, your drawing is actually performed upon an underlying <code><a href="../../../reference/android/graphics/Bitmap.html">Bitmap</a></code>, which is placed into the window.</p> 
 <p>In the event that you're drawing within the <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code></code> callback method, the Canvas is provided for you and you need only place your drawing calls upon it. You can also acquire a Canvas from <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">SurfaceHolder.lockCanvas()</a></code></code>, when dealing with a SurfaceView object. (Both of these scenarios are discussed in the following sections.) However, if you need to create a new Canvas, then you must define the <code><a href="../../../reference/android/graphics/Bitmap.html">Bitmap</a></code> upon which drawing will actually be performed. The Bitmap is always required for a Canvas. You can set up a new Canvas like this:</p> 
 <pre>
Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
Canvas c = new Canvas(b);
</pre> 
 <p>Now your Canvas will draw onto the defined Bitmap. After drawing upon it with the Canvas, you can then carry your Bitmap to another Canvas with one of the <code><code><a href="../../../reference/android/graphics/Canvas.html#drawBitmap(android.graphics.Bitmap, android.graphics.Matrix, android.graphics.Paint)">Canvas.drawBitmap(Bitmap,...)</a></code></code> methods. It's recommended that you ultimately draw your final graphics through a Canvas offered to you by <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">View.onDraw()</a></code></code> or <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">SurfaceHolder.lockCanvas()</a></code></code> (see the following sections).</p> 
 <p>The <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code> class has its own set of drawing methods that you can use, like <code>drawBitmap(...)</code>, <code>drawRect(...)</code>, <code>drawText(...)</code>, and many more. Other classes that you might use also have <code>draw()</code> methods. For example, you'll probably have some <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> objects that you want to put on the Canvas. Drawable has its own <code><code><a href="../../../reference/android/graphics/drawable/Drawable.html#draw(android.graphics.Canvas)">draw()</a></code></code> method that takes your Canvas as an argument.</p> 
 ","SurfaceHolder","android.view.SurfaceHolder","class",0
,"Draw with a Canvas","On a SurfaceView","<h3 id="on-surfaceview">On a SurfaceView</h3> 
 <p>The <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code> is a special subclass of View that offers a dedicated drawing surface within the View hierarchy. The aim is to offer this drawing surface to an application's secondary thread, so that the application isn't required to wait until the system's View hierarchy is ready to draw. Instead, a secondary thread that has reference to a SurfaceView can draw to its own Canvas at its own pace.</p> 
 <p>To begin, you need to create a new class that extends <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code>. The class should also implement <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code>. This subclass is an interface that will notify you with information about the underlying <code><a href="../../../reference/android/view/Surface.html">Surface</a></code>, such as when it is created, changed, or destroyed. These events are important so that you know when you can start drawing, whether you need to make adjustments based on new surface properties, and when to stop drawing and potentially kill some tasks. Inside your SurfaceView class is also a good place to define your secondary Thread class, which will perform all the drawing procedures to your Canvas.</p> 
 <p>Instead of handling the Surface object directly, you should handle it via a <code><a href="../../../reference/android/view/SurfaceHolder.html">SurfaceHolder</a></code>. So, when your SurfaceView is initialized, get the SurfaceHolder by calling <code><code><a href="../../../reference/android/view/SurfaceView.html#getHolder()">getHolder()</a></code></code>. You should then notify the SurfaceHolder that you'd like to receive SurfaceHolder callbacks (from <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code>) by calling <code><a href="../../../reference/android/view/SurfaceHolder.html#addCallback(android.view.SurfaceHolder.Callback)">addCallback()</a></code> (pass it <var>this</var>). Then override each of the <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code> methods inside your SurfaceView class.</p> 
 <p>In order to draw to the Surface Canvas from within your second thread, you must pass the thread your SurfaceHandler and retrieve the Canvas with <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">lockCanvas()</a></code></code>. You can now take the Canvas given to you by the SurfaceHolder and do your necessary drawing upon it. Once you're done drawing with the Canvas, call <code><code><a href="../../../reference/android/view/SurfaceHolder.html#unlockCanvasAndPost(android.graphics.Canvas)">unlockCanvasAndPost()</a></code></code>, passing it your Canvas object. The Surface will now draw the Canvas as you left it. Perform this sequence of locking and unlocking the canvas each time you want to redraw.</p> 
 <p class="note"><strong>Note:</strong> On each pass you retrieve the Canvas from the SurfaceHolder, the previous state of the Canvas will be retained. In order to properly animate your graphics, you must re-paint the entire surface. For example, you can clear the previous state of the Canvas by filling in a color with <code><code><a href="../../../reference/android/graphics/Canvas.html#drawColor(int)">drawColor()</a></code></code> or setting a background image with <code><code><a href="../../../reference/android/graphics/Canvas.html#drawBitmap(android.graphics.Bitmap, android.graphics.Rect, android.graphics.RectF, android.graphics.Paint)">drawBitmap()</a></code></code>. Otherwise, you will see traces of the drawings you previously performed.</p> 
 <p>For a sample application, see the Lunar Lander game, in the SDK samples folder: <code>&lt;your-sdk-directory&gt;/samples/LunarLander/</code>. Or, browse the source in the <a href="../../../guide/samples/index.html">Sample Code</a> section.</p> 
 ","SurfaceHolder","android.view.SurfaceHolder","class",1
,"Canvas and Drawables","Draw with a Canvas","<h2 id="draw-with-canvas">Draw with a Canvas</h2> 
 <p>When you're writing an application in which you would like to perform specialized drawing and/or control the animation of graphics, you should do so by drawing through a <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code>. A Canvas works for you as a pretense, or interface, to the actual surface upon which your graphics will be drawn ¡ª it holds all of your &quot;draw&quot; calls. Via the Canvas, your drawing is actually performed upon an underlying <code><a href="../../../reference/android/graphics/Bitmap.html">Bitmap</a></code>, which is placed into the window.</p> 
 <p>In the event that you're drawing within the <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">onDraw()</a></code></code> callback method, the Canvas is provided for you and you need only place your drawing calls upon it. You can also acquire a Canvas from <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">SurfaceHolder.lockCanvas()</a></code></code>, when dealing with a SurfaceView object. (Both of these scenarios are discussed in the following sections.) However, if you need to create a new Canvas, then you must define the <code><a href="../../../reference/android/graphics/Bitmap.html">Bitmap</a></code> upon which drawing will actually be performed. The Bitmap is always required for a Canvas. You can set up a new Canvas like this:</p> 
 <pre>
Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
Canvas c = new Canvas(b);
</pre> 
 <p>Now your Canvas will draw onto the defined Bitmap. After drawing upon it with the Canvas, you can then carry your Bitmap to another Canvas with one of the <code><code><a href="../../../reference/android/graphics/Canvas.html#drawBitmap(android.graphics.Bitmap, android.graphics.Matrix, android.graphics.Paint)">Canvas.drawBitmap(Bitmap,...)</a></code></code> methods. It's recommended that you ultimately draw your final graphics through a Canvas offered to you by <code><code><a href="../../../reference/android/view/View.html#onDraw(android.graphics.Canvas)">View.onDraw()</a></code></code> or <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">SurfaceHolder.lockCanvas()</a></code></code> (see the following sections).</p> 
 <p>The <code><a href="../../../reference/android/graphics/Canvas.html">Canvas</a></code> class has its own set of drawing methods that you can use, like <code>drawBitmap(...)</code>, <code>drawRect(...)</code>, <code>drawText(...)</code>, and many more. Other classes that you might use also have <code>draw()</code> methods. For example, you'll probably have some <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> objects that you want to put on the Canvas. Drawable has its own <code><code><a href="../../../reference/android/graphics/drawable/Drawable.html#draw(android.graphics.Canvas)">draw()</a></code></code> method that takes your Canvas as an argument.</p> 
 ","Drawable","android.graphics.drawable.Drawable","class",0
,"Canvas and Drawables","Drawables","<h2 id="drawables">Drawables</h2> 
 <p>Android offers a custom 2D graphics library for drawing shapes and images. The <code><a href="../../../reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a></code> package is where you'll find the common classes used for drawing in two-dimensions.</p> 
 <p>This document discusses the basics of using Drawable objects to draw graphics and how to use a couple subclasses of the Drawable class. For information on using Drawables to do frame-by-frame animation, see <a href="../../../guide/topics/graphics/drawable-animation.html">Drawable Animation</a>.</p> 
 <p>A <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> is a general abstraction for &quot;something that can be drawn.&quot; You'll discover that the Drawable class extends to define a variety of specific kinds of drawable graphics, including <code><a href="../../../reference/android/graphics/drawable/BitmapDrawable.html">BitmapDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/ShapeDrawable.html">ShapeDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/PictureDrawable.html">PictureDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/LayerDrawable.html">LayerDrawable</a></code>, and several more. Of course, you can also extend these to define your own custom Drawable objects that behave in unique ways.</p> 
 <p>There are three ways to define and instantiate a Drawable: using an image saved in your project resources; using an XML file that defines the Drawable properties; or using the normal class constructors. Below, we'll discuss each the first two techniques (using constructors is nothing new for an experienced developer).</p> 
 ","Drawable","android.graphics.drawable.Drawable","class",0
,"Creating from resource images","Example code","<h4>Example code</h4> 
 <p>The following code snippet demonstrates how to build an <code><a href="../../../reference/android/widget/ImageView.html">ImageView</a></code> that uses an image from drawable resources and add it to the layout.</p> 
 <pre>
  LinearLayout mLinearLayout;

  protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);

  // Create a LinearLayout in which to add the ImageView
  mLinearLayout = new LinearLayout(this);

  // Instantiate an ImageView and define its properties
  ImageView i = new ImageView(this);
  i.setImageResource(R.drawable.my_image);
  i.setAdjustViewBounds(true); // set the ImageView bounds to match the Drawable's dimensions
  i.setLayoutParams(new Gallery.LayoutParams(LayoutParams.WRAP_CONTENT,
  LayoutParams.WRAP_CONTENT));

  // Add the ImageView to the layout and set the layout as the content view
  mLinearLayout.addView(i);
  setContentView(mLinearLayout);
  }
</pre> 
 <p>In other cases, you may want to handle your image resource as a <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> object. To do so, create a Drawable from the resource like so: </p>
 <pre>
    Resources res = mContext.getResources();
    Drawable myImage = res.getDrawable(R.drawable.my_image);
  </pre> 
 <p class="warning"><strong>Note:</strong> Each unique resource in your project can maintain only one state, no matter how many different objects you may instantiate for it. For example, if you instantiate two Drawable objects from the same image resource, then change a property (such as the alpha) for one of the Drawables, then it will also affect the other. So when dealing with multiple instances of an image resource, instead of directly transforming the Drawable, you should perform a <a href="../../../guide/topics/graphics/view-animation.html#tween-animation">tween animation</a>.</p> 
 ","Drawable","android.graphics.drawable.Drawable","class",0
,"Canvas and Drawables","Shape Drawable","<h2 id="shape-drawable">Shape Drawable</h2> 
 <p>When you want to dynamically draw some two-dimensional graphics, a <code><a href="../../../reference/android/graphics/drawable/ShapeDrawable.html">ShapeDrawable</a></code> object will probably suit your needs. With a ShapeDrawable, you can programmatically draw primitive shapes and style them in any way imaginable.</p> 
 <p>A ShapeDrawable is an extension of <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code>, so you can use one where ever a Drawable is expected ¡ª perhaps for the background of a View, set with <code><a href="../../../reference/android/view/View.html#setBackgroundDrawable(android.graphics.drawable.Drawable)">setBackgroundDrawable()</a></code>. Of course, you can also draw your shape as its own custom <code><a href="../../../reference/android/view/View.html">View</a></code>, to be added to your layout however you please. Because the ShapeDrawable has its own <code>draw()</code> method, you can create a subclass of View that draws the ShapeDrawable during the <code>View.onDraw()</code> method. Here's a basic extension of the View class that does just this, to draw a ShapeDrawable as a View:</p> 
 <pre>
      public class CustomDrawableView extends View {
      private ShapeDrawable mDrawable;

      public CustomDrawableView(Context context) {
      super(context);

      int x = 10;
      int y = 10;
      int width = 300;
      int height = 50;

      mDrawable = new ShapeDrawable(new OvalShape());
      mDrawable.getPaint().setColor(0xff74AC23);
      mDrawable.setBounds(x, y, x + width, y + height);
      }

      protected void onDraw(Canvas canvas) {
      mDrawable.draw(canvas);
      }
      }
    </pre> 
 <p>In the constructor, a ShapeDrawable is defines as an <code><a href="../../../reference/android/graphics/drawable/shapes/OvalShape.html">OvalShape</a></code>. It's then given a color and the bounds of the shape are set. If you do not set the bounds, then the shape will not be drawn, whereas if you don't set the color, it will default to black.</p> 
 <p>With the custom View defined, it can be drawn any way you like. With the sample above, we can draw the shape programmatically in an Activity:</p> 
 <pre>
      CustomDrawableView mCustomDrawableView;

      protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      mCustomDrawableView = new CustomDrawableView(this);

      setContentView(mCustomDrawableView);
      }
    </pre> 
 <p>If you'd like to draw this custom drawable from the XML layout instead of from the Activity, then the CustomDrawable class must override the <code><a href="../../../reference/android/view/View.html#View(android.content.Context, android.util.AttributeSet)">View(Context, AttributeSet)</a></code> constructor, which is called when instantiating a View via inflation from XML. Then add a CustomDrawable element to the XML, like so:</p> 
 <pre>
      &lt;com.example.shapedrawable.CustomDrawableView
      android:layout_width=&quot;fill_parent&quot;
      android:layout_height=&quot;wrap_content&quot;
      /&gt;
  </pre> 
 <p>The ShapeDrawable class (like many other Drawable types in the <code><a href="../../../reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a></code> package) allows you to define various properties of the drawable with public methods. Some properties you might want to adjust include alpha transparency, color filter, dither, opacity and color.</p> 
 <p>You can also define primitive drawable shapes using XML. For more information, see the section about Shape Drawables in the <a href="../../../guide/topics/resources/drawable-resource.html#Shape">Drawable Resources</a> document.</p> 
 <!-- TODO
       ","Drawable","android.graphics.drawable.Drawable","class",0
,"Hardware Acceleration","Hardware Acceleration","<p>Beginning in Android 3.0 (API level 11), the Android 2D rendering pipeline supports hardware acceleration, meaning that all drawing operations that are performed on a <code><a href="../../../reference/android/view/View.html">View</a></code>'s canvas use the GPU. Because of the increased resources required to enable hardware acceleration, your app will consume more RAM.</p> 
 <p>Hardware acceleration is enabled by default if your Target API level is &gt;=14, but can also be explicitly enabled. If your application uses only standard views and <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code>s, turning it on globally should not cause any adverse drawing effects. However, because hardware acceleration is not supported for all of the 2D drawing operations, turning it on might affect some of your custom views or drawing calls. Problems usually manifest themselves as invisible elements, exceptions, or wrongly rendered pixels. To remedy this, Android gives you the option to enable or disable hardware acceleration at multiple levels. See <a href="#controlling">Controlling Hardware Acceleration</a>.</p> 
 <p>If your application performs custom drawing, test your application on actual hardware devices with hardware acceleration turned on to find any problems. The <a href="#drawing-support">Unsupported drawing operations</a> section describes known issues with hardware acceleration and how to work around them.</p> 
 ","Drawable","android.graphics.drawable.Drawable","class",0
,"Draw with a Canvas","On a SurfaceView","<h3 id="on-surfaceview">On a SurfaceView</h3> 
 <p>The <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code> is a special subclass of View that offers a dedicated drawing surface within the View hierarchy. The aim is to offer this drawing surface to an application's secondary thread, so that the application isn't required to wait until the system's View hierarchy is ready to draw. Instead, a secondary thread that has reference to a SurfaceView can draw to its own Canvas at its own pace.</p> 
 <p>To begin, you need to create a new class that extends <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code>. The class should also implement <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code>. This subclass is an interface that will notify you with information about the underlying <code><a href="../../../reference/android/view/Surface.html">Surface</a></code>, such as when it is created, changed, or destroyed. These events are important so that you know when you can start drawing, whether you need to make adjustments based on new surface properties, and when to stop drawing and potentially kill some tasks. Inside your SurfaceView class is also a good place to define your secondary Thread class, which will perform all the drawing procedures to your Canvas.</p> 
 <p>Instead of handling the Surface object directly, you should handle it via a <code><a href="../../../reference/android/view/SurfaceHolder.html">SurfaceHolder</a></code>. So, when your SurfaceView is initialized, get the SurfaceHolder by calling <code><code><a href="../../../reference/android/view/SurfaceView.html#getHolder()">getHolder()</a></code></code>. You should then notify the SurfaceHolder that you'd like to receive SurfaceHolder callbacks (from <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code>) by calling <code><a href="../../../reference/android/view/SurfaceHolder.html#addCallback(android.view.SurfaceHolder.Callback)">addCallback()</a></code> (pass it <var>this</var>). Then override each of the <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code> methods inside your SurfaceView class.</p> 
 <p>In order to draw to the Surface Canvas from within your second thread, you must pass the thread your SurfaceHandler and retrieve the Canvas with <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">lockCanvas()</a></code></code>. You can now take the Canvas given to you by the SurfaceHolder and do your necessary drawing upon it. Once you're done drawing with the Canvas, call <code><code><a href="../../../reference/android/view/SurfaceHolder.html#unlockCanvasAndPost(android.graphics.Canvas)">unlockCanvasAndPost()</a></code></code>, passing it your Canvas object. The Surface will now draw the Canvas as you left it. Perform this sequence of locking and unlocking the canvas each time you want to redraw.</p> 
 <p class="note"><strong>Note:</strong> On each pass you retrieve the Canvas from the SurfaceHolder, the previous state of the Canvas will be retained. In order to properly animate your graphics, you must re-paint the entire surface. For example, you can clear the previous state of the Canvas by filling in a color with <code><code><a href="../../../reference/android/graphics/Canvas.html#drawColor(int)">drawColor()</a></code></code> or setting a background image with <code><code><a href="../../../reference/android/graphics/Canvas.html#drawBitmap(android.graphics.Bitmap, android.graphics.Rect, android.graphics.RectF, android.graphics.Paint)">drawBitmap()</a></code></code>. Otherwise, you will see traces of the drawings you previously performed.</p> 
 <p>For a sample application, see the Lunar Lander game, in the SDK samples folder: <code>&lt;your-sdk-directory&gt;/samples/LunarLander/</code>. Or, browse the source in the <a href="../../../guide/samples/index.html">Sample Code</a> section.</p> 
 ","Surface","android.view.Surface","class",0
,"Draw with a Canvas","On a SurfaceView","<h3 id="on-surfaceview">On a SurfaceView</h3> 
 <p>The <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code> is a special subclass of View that offers a dedicated drawing surface within the View hierarchy. The aim is to offer this drawing surface to an application's secondary thread, so that the application isn't required to wait until the system's View hierarchy is ready to draw. Instead, a secondary thread that has reference to a SurfaceView can draw to its own Canvas at its own pace.</p> 
 <p>To begin, you need to create a new class that extends <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code>. The class should also implement <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code>. This subclass is an interface that will notify you with information about the underlying <code><a href="../../../reference/android/view/Surface.html">Surface</a></code>, such as when it is created, changed, or destroyed. These events are important so that you know when you can start drawing, whether you need to make adjustments based on new surface properties, and when to stop drawing and potentially kill some tasks. Inside your SurfaceView class is also a good place to define your secondary Thread class, which will perform all the drawing procedures to your Canvas.</p> 
 <p>Instead of handling the Surface object directly, you should handle it via a <code><a href="../../../reference/android/view/SurfaceHolder.html">SurfaceHolder</a></code>. So, when your SurfaceView is initialized, get the SurfaceHolder by calling <code><code><a href="../../../reference/android/view/SurfaceView.html#getHolder()">getHolder()</a></code></code>. You should then notify the SurfaceHolder that you'd like to receive SurfaceHolder callbacks (from <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code>) by calling <code><a href="../../../reference/android/view/SurfaceHolder.html#addCallback(android.view.SurfaceHolder.Callback)">addCallback()</a></code> (pass it <var>this</var>). Then override each of the <code><a href="../../../reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a></code> methods inside your SurfaceView class.</p> 
 <p>In order to draw to the Surface Canvas from within your second thread, you must pass the thread your SurfaceHandler and retrieve the Canvas with <code><code><a href="../../../reference/android/view/SurfaceHolder.html#lockCanvas()">lockCanvas()</a></code></code>. You can now take the Canvas given to you by the SurfaceHolder and do your necessary drawing upon it. Once you're done drawing with the Canvas, call <code><code><a href="../../../reference/android/view/SurfaceHolder.html#unlockCanvasAndPost(android.graphics.Canvas)">unlockCanvasAndPost()</a></code></code>, passing it your Canvas object. The Surface will now draw the Canvas as you left it. Perform this sequence of locking and unlocking the canvas each time you want to redraw.</p> 
 <p class="note"><strong>Note:</strong> On each pass you retrieve the Canvas from the SurfaceHolder, the previous state of the Canvas will be retained. In order to properly animate your graphics, you must re-paint the entire surface. For example, you can clear the previous state of the Canvas by filling in a color with <code><code><a href="../../../reference/android/graphics/Canvas.html#drawColor(int)">drawColor()</a></code></code> or setting a background image with <code><code><a href="../../../reference/android/graphics/Canvas.html#drawBitmap(android.graphics.Bitmap, android.graphics.Rect, android.graphics.RectF, android.graphics.Paint)">drawBitmap()</a></code></code>. Otherwise, you will see traces of the drawings you previously performed.</p> 
 <p>For a sample application, see the Lunar Lander game, in the SDK samples folder: <code>&lt;your-sdk-directory&gt;/samples/LunarLander/</code>. Or, browse the source in the <a href="../../../guide/samples/index.html">Sample Code</a> section.</p> 
 ","Callback","android.view.SurfaceHolder.Callback","class",0
,"Canvas and Drawables","Drawables","<h2 id="drawables">Drawables</h2> 
 <p>Android offers a custom 2D graphics library for drawing shapes and images. The <code><a href="../../../reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a></code> package is where you'll find the common classes used for drawing in two-dimensions.</p> 
 <p>This document discusses the basics of using Drawable objects to draw graphics and how to use a couple subclasses of the Drawable class. For information on using Drawables to do frame-by-frame animation, see <a href="../../../guide/topics/graphics/drawable-animation.html">Drawable Animation</a>.</p> 
 <p>A <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> is a general abstraction for &quot;something that can be drawn.&quot; You'll discover that the Drawable class extends to define a variety of specific kinds of drawable graphics, including <code><a href="../../../reference/android/graphics/drawable/BitmapDrawable.html">BitmapDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/ShapeDrawable.html">ShapeDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/PictureDrawable.html">PictureDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/LayerDrawable.html">LayerDrawable</a></code>, and several more. Of course, you can also extend these to define your own custom Drawable objects that behave in unique ways.</p> 
 <p>There are three ways to define and instantiate a Drawable: using an image saved in your project resources; using an XML file that defines the Drawable properties; or using the normal class constructors. Below, we'll discuss each the first two techniques (using constructors is nothing new for an experienced developer).</p> 
 ","LayerDrawable","android.graphics.drawable.LayerDrawable","class",0
,"Canvas and Drawables","Drawables","<h2 id="drawables">Drawables</h2> 
 <p>Android offers a custom 2D graphics library for drawing shapes and images. The <code><a href="../../../reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a></code> package is where you'll find the common classes used for drawing in two-dimensions.</p> 
 <p>This document discusses the basics of using Drawable objects to draw graphics and how to use a couple subclasses of the Drawable class. For information on using Drawables to do frame-by-frame animation, see <a href="../../../guide/topics/graphics/drawable-animation.html">Drawable Animation</a>.</p> 
 <p>A <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> is a general abstraction for &quot;something that can be drawn.&quot; You'll discover that the Drawable class extends to define a variety of specific kinds of drawable graphics, including <code><a href="../../../reference/android/graphics/drawable/BitmapDrawable.html">BitmapDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/ShapeDrawable.html">ShapeDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/PictureDrawable.html">PictureDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/LayerDrawable.html">LayerDrawable</a></code>, and several more. Of course, you can also extend these to define your own custom Drawable objects that behave in unique ways.</p> 
 <p>There are three ways to define and instantiate a Drawable: using an image saved in your project resources; using an XML file that defines the Drawable properties; or using the normal class constructors. Below, we'll discuss each the first two techniques (using constructors is nothing new for an experienced developer).</p> 
 ","ShapeDrawable","android.graphics.drawable.ShapeDrawable","class",0
,"Canvas and Drawables","Shape Drawable","<h2 id="shape-drawable">Shape Drawable</h2> 
 <p>When you want to dynamically draw some two-dimensional graphics, a <code><a href="../../../reference/android/graphics/drawable/ShapeDrawable.html">ShapeDrawable</a></code> object will probably suit your needs. With a ShapeDrawable, you can programmatically draw primitive shapes and style them in any way imaginable.</p> 
 <p>A ShapeDrawable is an extension of <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code>, so you can use one where ever a Drawable is expected ¡ª perhaps for the background of a View, set with <code><a href="../../../reference/android/view/View.html#setBackgroundDrawable(android.graphics.drawable.Drawable)">setBackgroundDrawable()</a></code>. Of course, you can also draw your shape as its own custom <code><a href="../../../reference/android/view/View.html">View</a></code>, to be added to your layout however you please. Because the ShapeDrawable has its own <code>draw()</code> method, you can create a subclass of View that draws the ShapeDrawable during the <code>View.onDraw()</code> method. Here's a basic extension of the View class that does just this, to draw a ShapeDrawable as a View:</p> 
 <pre>
      public class CustomDrawableView extends View {
      private ShapeDrawable mDrawable;

      public CustomDrawableView(Context context) {
      super(context);

      int x = 10;
      int y = 10;
      int width = 300;
      int height = 50;

      mDrawable = new ShapeDrawable(new OvalShape());
      mDrawable.getPaint().setColor(0xff74AC23);
      mDrawable.setBounds(x, y, x + width, y + height);
      }

      protected void onDraw(Canvas canvas) {
      mDrawable.draw(canvas);
      }
      }
    </pre> 
 <p>In the constructor, a ShapeDrawable is defines as an <code><a href="../../../reference/android/graphics/drawable/shapes/OvalShape.html">OvalShape</a></code>. It's then given a color and the bounds of the shape are set. If you do not set the bounds, then the shape will not be drawn, whereas if you don't set the color, it will default to black.</p> 
 <p>With the custom View defined, it can be drawn any way you like. With the sample above, we can draw the shape programmatically in an Activity:</p> 
 <pre>
      CustomDrawableView mCustomDrawableView;

      protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      mCustomDrawableView = new CustomDrawableView(this);

      setContentView(mCustomDrawableView);
      }
    </pre> 
 <p>If you'd like to draw this custom drawable from the XML layout instead of from the Activity, then the CustomDrawable class must override the <code><a href="../../../reference/android/view/View.html#View(android.content.Context, android.util.AttributeSet)">View(Context, AttributeSet)</a></code> constructor, which is called when instantiating a View via inflation from XML. Then add a CustomDrawable element to the XML, like so:</p> 
 <pre>
      &lt;com.example.shapedrawable.CustomDrawableView
      android:layout_width=&quot;fill_parent&quot;
      android:layout_height=&quot;wrap_content&quot;
      /&gt;
  </pre> 
 <p>The ShapeDrawable class (like many other Drawable types in the <code><a href="../../../reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a></code> package) allows you to define various properties of the drawable with public methods. Some properties you might want to adjust include alpha transparency, color filter, dither, opacity and color.</p> 
 <p>You can also define primitive drawable shapes using XML. For more information, see the section about Shape Drawables in the <a href="../../../guide/topics/resources/drawable-resource.html#Shape">Drawable Resources</a> document.</p> 
 <!-- TODO
       ","ShapeDrawable","android.graphics.drawable.ShapeDrawable","class",1
,"Canvas and Drawables","Drawables","<h2 id="drawables">Drawables</h2> 
 <p>Android offers a custom 2D graphics library for drawing shapes and images. The <code><a href="../../../reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a></code> package is where you'll find the common classes used for drawing in two-dimensions.</p> 
 <p>This document discusses the basics of using Drawable objects to draw graphics and how to use a couple subclasses of the Drawable class. For information on using Drawables to do frame-by-frame animation, see <a href="../../../guide/topics/graphics/drawable-animation.html">Drawable Animation</a>.</p> 
 <p>A <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> is a general abstraction for &quot;something that can be drawn.&quot; You'll discover that the Drawable class extends to define a variety of specific kinds of drawable graphics, including <code><a href="../../../reference/android/graphics/drawable/BitmapDrawable.html">BitmapDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/ShapeDrawable.html">ShapeDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/PictureDrawable.html">PictureDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/LayerDrawable.html">LayerDrawable</a></code>, and several more. Of course, you can also extend these to define your own custom Drawable objects that behave in unique ways.</p> 
 <p>There are three ways to define and instantiate a Drawable: using an image saved in your project resources; using an XML file that defines the Drawable properties; or using the normal class constructors. Below, we'll discuss each the first two techniques (using constructors is nothing new for an experienced developer).</p> 
 ","PictureDrawable","android.graphics.drawable.PictureDrawable","class",0
,"Canvas and Drawables","Drawables","<h2 id="drawables">Drawables</h2> 
 <p>Android offers a custom 2D graphics library for drawing shapes and images. The <code><a href="../../../reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a></code> package is where you'll find the common classes used for drawing in two-dimensions.</p> 
 <p>This document discusses the basics of using Drawable objects to draw graphics and how to use a couple subclasses of the Drawable class. For information on using Drawables to do frame-by-frame animation, see <a href="../../../guide/topics/graphics/drawable-animation.html">Drawable Animation</a>.</p> 
 <p>A <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> is a general abstraction for &quot;something that can be drawn.&quot; You'll discover that the Drawable class extends to define a variety of specific kinds of drawable graphics, including <code><a href="../../../reference/android/graphics/drawable/BitmapDrawable.html">BitmapDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/ShapeDrawable.html">ShapeDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/PictureDrawable.html">PictureDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/LayerDrawable.html">LayerDrawable</a></code>, and several more. Of course, you can also extend these to define your own custom Drawable objects that behave in unique ways.</p> 
 <p>There are three ways to define and instantiate a Drawable: using an image saved in your project resources; using an XML file that defines the Drawable properties; or using the normal class constructors. Below, we'll discuss each the first two techniques (using constructors is nothing new for an experienced developer).</p> 
 ","BitmapDrawable","android.graphics.drawable.BitmapDrawable","class",0
,"Canvas and Drawables","Drawables","<h2 id="drawables">Drawables</h2> 
 <p>Android offers a custom 2D graphics library for drawing shapes and images. The <code><a href="../../../reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a></code> package is where you'll find the common classes used for drawing in two-dimensions.</p> 
 <p>This document discusses the basics of using Drawable objects to draw graphics and how to use a couple subclasses of the Drawable class. For information on using Drawables to do frame-by-frame animation, see <a href="../../../guide/topics/graphics/drawable-animation.html">Drawable Animation</a>.</p> 
 <p>A <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> is a general abstraction for &quot;something that can be drawn.&quot; You'll discover that the Drawable class extends to define a variety of specific kinds of drawable graphics, including <code><a href="../../../reference/android/graphics/drawable/BitmapDrawable.html">BitmapDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/ShapeDrawable.html">ShapeDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/PictureDrawable.html">PictureDrawable</a></code>, <code><a href="../../../reference/android/graphics/drawable/LayerDrawable.html">LayerDrawable</a></code>, and several more. Of course, you can also extend these to define your own custom Drawable objects that behave in unique ways.</p> 
 <p>There are three ways to define and instantiate a Drawable: using an image saved in your project resources; using an XML file that defines the Drawable properties; or using the normal class constructors. Below, we'll discuss each the first two techniques (using constructors is nothing new for an experienced developer).</p> 
 ","package-summary","android.graphics.drawable.package-summary","class",1
,"Canvas and Drawables","Shape Drawable","<h2 id="shape-drawable">Shape Drawable</h2> 
 <p>When you want to dynamically draw some two-dimensional graphics, a <code><a href="../../../reference/android/graphics/drawable/ShapeDrawable.html">ShapeDrawable</a></code> object will probably suit your needs. With a ShapeDrawable, you can programmatically draw primitive shapes and style them in any way imaginable.</p> 
 <p>A ShapeDrawable is an extension of <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code>, so you can use one where ever a Drawable is expected ¡ª perhaps for the background of a View, set with <code><a href="../../../reference/android/view/View.html#setBackgroundDrawable(android.graphics.drawable.Drawable)">setBackgroundDrawable()</a></code>. Of course, you can also draw your shape as its own custom <code><a href="../../../reference/android/view/View.html">View</a></code>, to be added to your layout however you please. Because the ShapeDrawable has its own <code>draw()</code> method, you can create a subclass of View that draws the ShapeDrawable during the <code>View.onDraw()</code> method. Here's a basic extension of the View class that does just this, to draw a ShapeDrawable as a View:</p> 
 <pre>
      public class CustomDrawableView extends View {
      private ShapeDrawable mDrawable;

      public CustomDrawableView(Context context) {
      super(context);

      int x = 10;
      int y = 10;
      int width = 300;
      int height = 50;

      mDrawable = new ShapeDrawable(new OvalShape());
      mDrawable.getPaint().setColor(0xff74AC23);
      mDrawable.setBounds(x, y, x + width, y + height);
      }

      protected void onDraw(Canvas canvas) {
      mDrawable.draw(canvas);
      }
      }
    </pre> 
 <p>In the constructor, a ShapeDrawable is defines as an <code><a href="../../../reference/android/graphics/drawable/shapes/OvalShape.html">OvalShape</a></code>. It's then given a color and the bounds of the shape are set. If you do not set the bounds, then the shape will not be drawn, whereas if you don't set the color, it will default to black.</p> 
 <p>With the custom View defined, it can be drawn any way you like. With the sample above, we can draw the shape programmatically in an Activity:</p> 
 <pre>
      CustomDrawableView mCustomDrawableView;

      protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      mCustomDrawableView = new CustomDrawableView(this);

      setContentView(mCustomDrawableView);
      }
    </pre> 
 <p>If you'd like to draw this custom drawable from the XML layout instead of from the Activity, then the CustomDrawable class must override the <code><a href="../../../reference/android/view/View.html#View(android.content.Context, android.util.AttributeSet)">View(Context, AttributeSet)</a></code> constructor, which is called when instantiating a View via inflation from XML. Then add a CustomDrawable element to the XML, like so:</p> 
 <pre>
      &lt;com.example.shapedrawable.CustomDrawableView
      android:layout_width=&quot;fill_parent&quot;
      android:layout_height=&quot;wrap_content&quot;
      /&gt;
  </pre> 
 <p>The ShapeDrawable class (like many other Drawable types in the <code><a href="../../../reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a></code> package) allows you to define various properties of the drawable with public methods. Some properties you might want to adjust include alpha transparency, color filter, dither, opacity and color.</p> 
 <p>You can also define primitive drawable shapes using XML. For more information, see the section about Shape Drawables in the <a href="../../../guide/topics/resources/drawable-resource.html#Shape">Drawable Resources</a> document.</p> 
 <!-- TODO
       ","package-summary","android.graphics.drawable.package-summary","class",0
,"Creating from resource images","Example code","<h4>Example code</h4> 
 <p>The following code snippet demonstrates how to build an <code><a href="../../../reference/android/widget/ImageView.html">ImageView</a></code> that uses an image from drawable resources and add it to the layout.</p> 
 <pre>
  LinearLayout mLinearLayout;

  protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);

  // Create a LinearLayout in which to add the ImageView
  mLinearLayout = new LinearLayout(this);

  // Instantiate an ImageView and define its properties
  ImageView i = new ImageView(this);
  i.setImageResource(R.drawable.my_image);
  i.setAdjustViewBounds(true); // set the ImageView bounds to match the Drawable's dimensions
  i.setLayoutParams(new Gallery.LayoutParams(LayoutParams.WRAP_CONTENT,
  LayoutParams.WRAP_CONTENT));

  // Add the ImageView to the layout and set the layout as the content view
  mLinearLayout.addView(i);
  setContentView(mLinearLayout);
  }
</pre> 
 <p>In other cases, you may want to handle your image resource as a <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code> object. To do so, create a Drawable from the resource like so: </p>
 <pre>
    Resources res = mContext.getResources();
    Drawable myImage = res.getDrawable(R.drawable.my_image);
  </pre> 
 <p class="warning"><strong>Note:</strong> Each unique resource in your project can maintain only one state, no matter how many different objects you may instantiate for it. For example, if you instantiate two Drawable objects from the same image resource, then change a property (such as the alpha) for one of the Drawables, then it will also affect the other. So when dealing with multiple instances of an image resource, instead of directly transforming the Drawable, you should perform a <a href="../../../guide/topics/graphics/view-animation.html#tween-animation">tween animation</a>.</p> 
 ","ImageView","android.widget.ImageView","class",0
,"Creating from resource images","Example XML","<h4>Example XML</h4> 
 <p>The XML snippet below shows how to add a resource Drawable to an <code><a href="../../../reference/android/widget/ImageView.html">ImageView</a></code> in the XML layout (with some red tint just for fun). </p>
 <pre>
      &lt;ImageView
      android:layout_width=&quot;wrap_content&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:tint=&quot;#55ff0000&quot;
      android:src=&quot;@drawable/my_image&quot;/&gt;
  </pre> 
 <p>For more information on using project resources, read about <a href="../../../guide/topics/resources/index.html">Resources and Assets</a>.</p> 
 ","ImageView","android.widget.ImageView","class",0
,"Drawables","Creating from resource XML","<h3 id="drawables-from-xml">Creating from resource XML</h3> 
 <p>By now, you should be familiar with Android's principles of developing a <a href="../../../guide/topics/ui/index.html">User Interface</a>. Hence, you understand the power and flexibility inherent in defining objects in XML. This philosophy caries over from Views to Drawables. If there is a Drawable object that you'd like to create, which is not initially dependent on variables defined by your application code or user interaction, then defining the Drawable in XML is a good option. Even if you expect your Drawable to change its properties during the user's experience with your application, you should consider defining the object in XML, as you can always modify properties once it is instantiated.</p> 
 <p>Once you've defined your Drawable in XML, save the file in the <code>res/drawable/</code> directory of your project. Then, retrieve and instantiate the object by calling <code><a href="../../../reference/android/content/res/Resources.html#getDrawable(int)">Resources.getDrawable()</a></code>, passing it the resource ID of your XML file. (See the <a href="#drawable-xml-example">example below</a>.)</p> 
 <p>Any Drawable subclass that supports the <code>inflate()</code> method can be defined in XML and instantiated by your application. Each Drawable that supports XML inflation utilizes specific XML attributes that help define the object properties (see the class reference to see what these are). See the class documentation for each Drawable subclass for information on how to define it in XML. </p>
 ","Resources","android.content.res.Resources","class",0
,"Canvas and Drawables","Shape Drawable","<h2 id="shape-drawable">Shape Drawable</h2> 
 <p>When you want to dynamically draw some two-dimensional graphics, a <code><a href="../../../reference/android/graphics/drawable/ShapeDrawable.html">ShapeDrawable</a></code> object will probably suit your needs. With a ShapeDrawable, you can programmatically draw primitive shapes and style them in any way imaginable.</p> 
 <p>A ShapeDrawable is an extension of <code><a href="../../../reference/android/graphics/drawable/Drawable.html">Drawable</a></code>, so you can use one where ever a Drawable is expected ¡ª perhaps for the background of a View, set with <code><a href="../../../reference/android/view/View.html#setBackgroundDrawable(android.graphics.drawable.Drawable)">setBackgroundDrawable()</a></code>. Of course, you can also draw your shape as its own custom <code><a href="../../../reference/android/view/View.html">View</a></code>, to be added to your layout however you please. Because the ShapeDrawable has its own <code>draw()</code> method, you can create a subclass of View that draws the ShapeDrawable during the <code>View.onDraw()</code> method. Here's a basic extension of the View class that does just this, to draw a ShapeDrawable as a View:</p> 
 <pre>
      public class CustomDrawableView extends View {
      private ShapeDrawable mDrawable;

      public CustomDrawableView(Context context) {
      super(context);

      int x = 10;
      int y = 10;
      int width = 300;
      int height = 50;

      mDrawable = new ShapeDrawable(new OvalShape());
      mDrawable.getPaint().setColor(0xff74AC23);
      mDrawable.setBounds(x, y, x + width, y + height);
      }

      protected void onDraw(Canvas canvas) {
      mDrawable.draw(canvas);
      }
      }
    </pre> 
 <p>In the constructor, a ShapeDrawable is defines as an <code><a href="../../../reference/android/graphics/drawable/shapes/OvalShape.html">OvalShape</a></code>. It's then given a color and the bounds of the shape are set. If you do not set the bounds, then the shape will not be drawn, whereas if you don't set the color, it will default to black.</p> 
 <p>With the custom View defined, it can be drawn any way you like. With the sample above, we can draw the shape programmatically in an Activity:</p> 
 <pre>
      CustomDrawableView mCustomDrawableView;

      protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      mCustomDrawableView = new CustomDrawableView(this);

      setContentView(mCustomDrawableView);
      }
    </pre> 
 <p>If you'd like to draw this custom drawable from the XML layout instead of from the Activity, then the CustomDrawable class must override the <code><a href="../../../reference/android/view/View.html#View(android.content.Context, android.util.AttributeSet)">View(Context, AttributeSet)</a></code> constructor, which is called when instantiating a View via inflation from XML. Then add a CustomDrawable element to the XML, like so:</p> 
 <pre>
      &lt;com.example.shapedrawable.CustomDrawableView
      android:layout_width=&quot;fill_parent&quot;
      android:layout_height=&quot;wrap_content&quot;
      /&gt;
  </pre> 
 <p>The ShapeDrawable class (like many other Drawable types in the <code><a href="../../../reference/android/graphics/drawable/package-summary.html">android.graphics.drawable</a></code> package) allows you to define various properties of the drawable with public methods. Some properties you might want to adjust include alpha transparency, color filter, dither, opacity and color.</p> 
 <p>You can also define primitive drawable shapes using XML. For more information, see the section about Shape Drawables in the <a href="../../../guide/topics/resources/drawable-resource.html#Shape">Drawable Resources</a> document.</p> 
 <!-- TODO
       ","OvalShape","android.graphics.drawable.shapes.OvalShape","class",0
,"Canvas and Drawables","Nine-patch","<h2 id="nine-patch">Nine-patch</h2> 
 <p>A <code><a href="../../../reference/android/graphics/drawable/NinePatchDrawable.html">NinePatchDrawable</a></code> graphic is a stretchable bitmap image, which Android will automatically resize to accommodate the contents of the View in which you have placed it as the background. An example use of a NinePatch is the backgrounds used by standard Android buttons ¡ª buttons must stretch to accommodate strings of various lengths. A NinePatch drawable is a standard PNG image that includes an extra 1-pixel-wide border. It must be saved with the extension <code>.9.png</code>, and saved into the <code>res/drawable/</code> directory of your project. </p> 
 <p> The border is used to define the stretchable and static areas of the image. You indicate a stretchable section by drawing one (or more) 1-pixel-wide black line(s) in the left and top part of the border (the other border pixels should be fully transparent or white). You can have as many stretchable sections as you want: their relative size stays the same, so the largest sections always remain the largest. </p> 
 <p> You can also define an optional drawable section of the image (effectively, the padding lines) by drawing a line on the right and bottom lines. If a View object sets the NinePatch as its background and then specifies the View's text, it will stretch itself so that all the text fits inside only the area designated by the right and bottom lines (if included). If the padding lines are not included, Android uses the left and top lines to define this drawable area. </p> 
 <p>To clarify the difference between the different lines, the left and top lines define which pixels of the image are allowed to be replicated in order to stretch the image. The bottom and right lines define the relative area within the image that the contents of the View are allowed to lie within.</p> 
 <p> Here is a sample NinePatch file used to define a button: </p> 
 <img src="../../../images/ninepatch_raw.png" alt="" /> 
 <p>This NinePatch defines one stretchable area with the left and top lines and the drawable area with the bottom and right lines. In the top image, the dotted grey lines identify the regions of the image that will be replicated in order to stretch the image. The pink rectangle in the bottom image identifies the region in which the contents of the View are allowed. If the contents don't fit in this region, then the image will be stretched so that they do. </p> 
 <p>The <a href="../../../tools/help/draw9patch.html">Draw 9-patch</a> tool offers an extremely handy way to create your NinePatch images, using a WYSIWYG graphics editor. It even raises warnings if the region you've defined for the stretchable area is at risk of producing drawing artifacts as a result of the pixel replication. </p> 
 ","NinePatchDrawable","android.graphics.drawable.NinePatchDrawable","class",1
,"Android Drawing Models","Software-based drawing model","<h3 id="software-model">Software-based drawing model</h3> 
 <p>In the software drawing model, views are drawn with the following two steps:</p> 
 <ol> 
  <li>Invalidate the hierarchy</li> 
  <li>Draw the hierarchy</li> 
 </ol> 
 <p>Whenever an application needs to update a part of its UI, it invokes <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> (or one of its variants) on any view that has changed content. The invalidation messages are propagated all the way up the view hierarchy to compute the regions of the screen that need to be redrawn (the dirty region). The Android system then draws any view in the hierarchy that intersects with the dirty region. Unfortunately, there are two drawbacks to this drawing model:</p> 
 <ul> 
  <li>First, this model requires execution of a lot of code on every draw pass. For example, if your application calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> on a button and that button sits on top of another view, the Android system redraws the view even though it hasn't changed.</li> 
  <li>The second issue is that the drawing model can hide bugs in your application. Since the Android system redraws views when they intersect the dirty region, a view whose content you changed might be redrawn even though <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> was not called on it. When this happens, you are relying on another view being invalidated to obtain the proper behavior. This behavior can change every time you modify your application. Because of this, you should always call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> on your custom views whenever you modify data or state that affects the view¡¯s drawing code.</li> 
 </ul> 
 <p class="note"><strong>Note</strong>: Android views automatically call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> when their properties change, such as the background color or the text in a <code><a href="../../../reference/android/widget/TextView.html">TextView</a></code>.</p> 
 ","TextView","android.widget.TextView","class",0
,"Android Drawing Models","Hardware accelerated drawing model","<h3 id="hardware-model">Hardware accelerated drawing model</h3> 
 <p>The Android system still uses <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> and <code><a href="../../../reference/android/view/View.html#draw(android.graphics.Canvas)">draw()</a></code> to request screen updates and to render views, but handles the actual drawing differently. Instead of executing the drawing commands immediately, the Android system records them inside display lists, which contain the output of the view hierarchy¡¯s drawing code. Another optimization is that the Android system only needs to record and update display lists for views marked dirty by an <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> call. Views that have not been invalidated can be redrawn simply by re-issuing the previously recorded display list. The new drawing model contains three stages:</p> 
 <ol> 
  <li>Invalidate the hierarchy</li> 
  <li>Record and update display lists</li> 
  <li>Draw the display lists</li> 
 </ol> 
 <p>With this model, you cannot rely on a view intersecting the dirty region to have its <code><a href="../../../reference/android/view/View.html#draw(android.graphics.Canvas)">draw()</a></code> method executed. To ensure that the Android system records a view¡¯s display list, you must call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code>. Forgetting to do so causes a view to look the same even after it has been changed.</p> 
 <p>Using display lists also benefits animation performance because setting specific properties, such as alpha or rotation, does not require invalidating the targeted view (it is done automatically). This optimization also applies to views with display lists (any view when your application is hardware accelerated.) For example, assume there is a <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code> that contains a <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code> above a <code><a href="../../../reference/android/widget/Button.html">Button</a></code>. The display list for the <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code> looks like this:</p> 
 <ul> 
  <li>DrawDisplayList(ListView)</li> 
  <li>DrawDisplayList(Button)</li> 
 </ul> 
 <p>Assume now that you want to change the <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code>'s opacity. After invoking <code>setAlpha(0.5f)</code> on the <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code>, the display list now contains this:</p> 
 <ul> 
  <li>SaveLayerAlpha(0.5)</li> 
  <li>DrawDisplayList(ListView)</li> 
  <li>Restore</li> 
  <li>DrawDisplayList(Button)</li> 
 </ul> 
 <p>The complex drawing code of <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code> was not executed. Instead, the system only updated the display list of the much simpler <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code>. In an application without hardware acceleration enabled, the drawing code of both the list and its parent are executed again.</p> 
 ","LinearLayout","android.widget.LinearLayout","class",1
,"Android Drawing Models","Hardware accelerated drawing model","<h3 id="hardware-model">Hardware accelerated drawing model</h3> 
 <p>The Android system still uses <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> and <code><a href="../../../reference/android/view/View.html#draw(android.graphics.Canvas)">draw()</a></code> to request screen updates and to render views, but handles the actual drawing differently. Instead of executing the drawing commands immediately, the Android system records them inside display lists, which contain the output of the view hierarchy¡¯s drawing code. Another optimization is that the Android system only needs to record and update display lists for views marked dirty by an <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> call. Views that have not been invalidated can be redrawn simply by re-issuing the previously recorded display list. The new drawing model contains three stages:</p> 
 <ol> 
  <li>Invalidate the hierarchy</li> 
  <li>Record and update display lists</li> 
  <li>Draw the display lists</li> 
 </ol> 
 <p>With this model, you cannot rely on a view intersecting the dirty region to have its <code><a href="../../../reference/android/view/View.html#draw(android.graphics.Canvas)">draw()</a></code> method executed. To ensure that the Android system records a view¡¯s display list, you must call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code>. Forgetting to do so causes a view to look the same even after it has been changed.</p> 
 <p>Using display lists also benefits animation performance because setting specific properties, such as alpha or rotation, does not require invalidating the targeted view (it is done automatically). This optimization also applies to views with display lists (any view when your application is hardware accelerated.) For example, assume there is a <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code> that contains a <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code> above a <code><a href="../../../reference/android/widget/Button.html">Button</a></code>. The display list for the <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code> looks like this:</p> 
 <ul> 
  <li>DrawDisplayList(ListView)</li> 
  <li>DrawDisplayList(Button)</li> 
 </ul> 
 <p>Assume now that you want to change the <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code>'s opacity. After invoking <code>setAlpha(0.5f)</code> on the <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code>, the display list now contains this:</p> 
 <ul> 
  <li>SaveLayerAlpha(0.5)</li> 
  <li>DrawDisplayList(ListView)</li> 
  <li>Restore</li> 
  <li>DrawDisplayList(Button)</li> 
 </ul> 
 <p>The complex drawing code of <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code> was not executed. Instead, the system only updated the display list of the much simpler <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code>. In an application without hardware acceleration enabled, the drawing code of both the list and its parent are executed again.</p> 
 ","Button","android.widget.Button","class",0
,"Android Drawing Models","Hardware accelerated drawing model","<h3 id="hardware-model">Hardware accelerated drawing model</h3> 
 <p>The Android system still uses <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> and <code><a href="../../../reference/android/view/View.html#draw(android.graphics.Canvas)">draw()</a></code> to request screen updates and to render views, but handles the actual drawing differently. Instead of executing the drawing commands immediately, the Android system records them inside display lists, which contain the output of the view hierarchy¡¯s drawing code. Another optimization is that the Android system only needs to record and update display lists for views marked dirty by an <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> call. Views that have not been invalidated can be redrawn simply by re-issuing the previously recorded display list. The new drawing model contains three stages:</p> 
 <ol> 
  <li>Invalidate the hierarchy</li> 
  <li>Record and update display lists</li> 
  <li>Draw the display lists</li> 
 </ol> 
 <p>With this model, you cannot rely on a view intersecting the dirty region to have its <code><a href="../../../reference/android/view/View.html#draw(android.graphics.Canvas)">draw()</a></code> method executed. To ensure that the Android system records a view¡¯s display list, you must call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code>. Forgetting to do so causes a view to look the same even after it has been changed.</p> 
 <p>Using display lists also benefits animation performance because setting specific properties, such as alpha or rotation, does not require invalidating the targeted view (it is done automatically). This optimization also applies to views with display lists (any view when your application is hardware accelerated.) For example, assume there is a <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code> that contains a <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code> above a <code><a href="../../../reference/android/widget/Button.html">Button</a></code>. The display list for the <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code> looks like this:</p> 
 <ul> 
  <li>DrawDisplayList(ListView)</li> 
  <li>DrawDisplayList(Button)</li> 
 </ul> 
 <p>Assume now that you want to change the <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code>'s opacity. After invoking <code>setAlpha(0.5f)</code> on the <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code>, the display list now contains this:</p> 
 <ul> 
  <li>SaveLayerAlpha(0.5)</li> 
  <li>DrawDisplayList(ListView)</li> 
  <li>Restore</li> 
  <li>DrawDisplayList(Button)</li> 
 </ul> 
 <p>The complex drawing code of <code><a href="../../../reference/android/widget/ListView.html">ListView</a></code> was not executed. Instead, the system only updated the display list of the much simpler <code><a href="../../../reference/android/widget/LinearLayout.html">LinearLayout</a></code>. In an application without hardware acceleration enabled, the drawing code of both the list and its parent are executed again.</p> 
 ","ListView","android.widget.ListView","class",0
,"Hardware Acceleration","View Layers","<h2 id="layers">View Layers</h2> 
 <p>In all versions of Android, views have had the ability to render into off-screen buffers, either by using a view's drawing cache, or by using <code><a href="../../../reference/android/graphics/Canvas.html#saveLayer(android.graphics.RectF, android.graphics.Paint, int)">Canvas.saveLayer()</a></code>. Off-screen buffers, or layers, have several uses. You can use them to get better performance when animating complex views or to apply composition effects. For instance, you can implement fade effects using <code>Canvas.saveLayer()</code> to temporarily render a view into a layer and then composite it back on screen with an opacity factor.</p> 
 <p>Beginning in Android 3.0 (API level 11), you have more control on how and when to use layers with the <code><a href="../../../reference/android/view/View.html#setLayerType(int, android.graphics.Paint)">View.setLayerType()</a></code> method. This API takes two parameters: the type of layer you want to use and an optional <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> object that describes how the layer should be composited. You can use the <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> parameter to apply color filters, special blending modes, or opacity to a layer. A view can use one of three layer types:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_NONE">LAYER_TYPE_NONE</a></code>: The view is rendered normally and is not backed by an off-screen buffer. This is the default behavior.</li> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_HARDWARE">LAYER_TYPE_HARDWARE</a></code>: The view is rendered in hardware into a hardware texture if the application is hardware accelerated. If the application is not hardware accelerated, this layer type behaves the same as <code><a href="../../../reference/android/view/View.html#LAYER_TYPE_SOFTWARE">LAYER_TYPE_SOFTWARE</a></code>.</li> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_SOFTWARE">LAYER_TYPE_SOFTWARE</a></code>: The view is rendered in software into a bitmap.</li> 
 </ul> 
 <p>The type of layer you use depends on your goal:</p> 
 <ul> 
  <li><strong>Performance</strong>: Use a hardware layer type to render a view into a hardware texture. Once a view is rendered into a layer, its drawing code does not have to be executed until the view calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code>. Some animations, such as alpha animations, can then be applied directly onto the layer, which is very efficient for the GPU to do.</li> 
  <li><strong>Visual effects</strong>: Use a hardware or software layer type and a <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> to apply special visual treatments to a view. For instance, you can draw a view in black and white using a <code><a href="../../../reference/android/graphics/ColorMatrixColorFilter.html">ColorMatrixColorFilter</a></code>.</li> 
  <li><strong>Compatibility</strong>: Use a software layer type to force a view to be rendered in software. If a view that is hardware accelerated (for instance, if your whole application is hardware acclerated), is having rendering problems, this is an easy way to work around limitations of the hardware rendering pipeline.</li> 
 </ul> 
 ","Paint","android.graphics.Paint","class",0
,"Hardware Acceleration","Tips and Tricks","<h2 id="tips">Tips and Tricks</h2> 
 <p>Switching to hardware accelerated 2D graphics can instantly increase performance, but you should still design your application to use the GPU effectively by following these recommendations:</p> 
 <dl> 
  <dt>
   <strong>Reduce the number of views in your application</strong>
  </dt> 
  <dd>
   The more views the system has to draw, the slower it will be. This applies to the software rendering pipeline as well. Reducing views is one of the easiest ways to optimize your UI.
  </dd> 
  <dt>
   <strong>Avoid overdraw</strong>
  </dt> 
  <dd>
   Do not draw too many layers on top of each other. Remove any views that are completely obscured by other opaque views on top of it. If you need to draw several layers blended on top of each other, consider merging them into a single layer. A good rule of thumb with current hardware is to not draw more than 2.5 times the number of pixels on screen per frame (transparent pixels in a bitmap count!).
  </dd> 
  <dt>
   <strong>Don't create render objects in draw methods</strong>
  </dt> 
  <dd>
   A common mistake is to create a new 
   <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> or a new 
   <code><a href="../../../reference/android/graphics/Path.html">Path</a></code> every time a rendering method is invoked. This forces the garbage collector to run more often and also bypasses caches and optimizations in the hardware pipeline.
  </dd> 
  <dt>
   <strong>Don't modify shapes too often</strong>
  </dt> 
  <dd>
   Complex shapes, paths, and circles for instance, are rendered using texture masks. Every time you create or modify a path, the hardware pipeline creates a new mask, which can be expensive.
  </dd> 
  <dt>
   <strong>Don't modify bitmaps too often</strong>
  </dt> 
  <dd>
   Every time you change the content of a bitmap, it is uploaded again as a GPU texture the next time you draw it.
  </dd> 
  <dt>
   <strong>Use alpha with care</strong>
  </dt> 
  <dd>
   When you make a view translucent using 
   <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code>, 
   <code><a href="../../../reference/android/view/animation/AlphaAnimation.html">AlphaAnimation</a></code>, or 
   <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, it is rendered in an off-screen buffer which doubles the required fill-rate. When applying alpha on very large views, consider setting the view's layer type to 
   <code>LAYER_TYPE_HARDWARE</code>.
  </dd> 
 </dl> 
</div> 
","Paint","android.graphics.Paint","class",0
,"Hardware Acceleration","View Layers","<h2 id="layers">View Layers</h2> 
 <p>In all versions of Android, views have had the ability to render into off-screen buffers, either by using a view's drawing cache, or by using <code><a href="../../../reference/android/graphics/Canvas.html#saveLayer(android.graphics.RectF, android.graphics.Paint, int)">Canvas.saveLayer()</a></code>. Off-screen buffers, or layers, have several uses. You can use them to get better performance when animating complex views or to apply composition effects. For instance, you can implement fade effects using <code>Canvas.saveLayer()</code> to temporarily render a view into a layer and then composite it back on screen with an opacity factor.</p> 
 <p>Beginning in Android 3.0 (API level 11), you have more control on how and when to use layers with the <code><a href="../../../reference/android/view/View.html#setLayerType(int, android.graphics.Paint)">View.setLayerType()</a></code> method. This API takes two parameters: the type of layer you want to use and an optional <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> object that describes how the layer should be composited. You can use the <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> parameter to apply color filters, special blending modes, or opacity to a layer. A view can use one of three layer types:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_NONE">LAYER_TYPE_NONE</a></code>: The view is rendered normally and is not backed by an off-screen buffer. This is the default behavior.</li> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_HARDWARE">LAYER_TYPE_HARDWARE</a></code>: The view is rendered in hardware into a hardware texture if the application is hardware accelerated. If the application is not hardware accelerated, this layer type behaves the same as <code><a href="../../../reference/android/view/View.html#LAYER_TYPE_SOFTWARE">LAYER_TYPE_SOFTWARE</a></code>.</li> 
  <li><code><a href="../../../reference/android/view/View.html#LAYER_TYPE_SOFTWARE">LAYER_TYPE_SOFTWARE</a></code>: The view is rendered in software into a bitmap.</li> 
 </ul> 
 <p>The type of layer you use depends on your goal:</p> 
 <ul> 
  <li><strong>Performance</strong>: Use a hardware layer type to render a view into a hardware texture. Once a view is rendered into a layer, its drawing code does not have to be executed until the view calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code>. Some animations, such as alpha animations, can then be applied directly onto the layer, which is very efficient for the GPU to do.</li> 
  <li><strong>Visual effects</strong>: Use a hardware or software layer type and a <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> to apply special visual treatments to a view. For instance, you can draw a view in black and white using a <code><a href="../../../reference/android/graphics/ColorMatrixColorFilter.html">ColorMatrixColorFilter</a></code>.</li> 
  <li><strong>Compatibility</strong>: Use a software layer type to force a view to be rendered in software. If a view that is hardware accelerated (for instance, if your whole application is hardware acclerated), is having rendering problems, this is an easy way to work around limitations of the hardware rendering pipeline.</li> 
 </ul> 
 ","ColorMatrixColorFilter","android.graphics.ColorMatrixColorFilter","class",0
,"View Layers","View layers and animations","<h3 id="layers-anims">View layers and animations</h3> 
 <p>Hardware layers can deliver faster and smoother animations when your application is hardware accelerated. Running an animation at 60 frames per second is not always possible when animating complex views that issue a lot of drawing operations. This can be alleviated by using hardware layers to render the view to a hardware texture. The hardware texture can then be used to animate the view, eliminating the need for the view to constantly redraw itself when it is being animated. The view is not redrawn unless you change the view's properties, which calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code>, or if you call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> manually. If you are running an animation in your application and do not obtain the smooth results you want, consider enabling hardware layers on your animated views.</p> 
 <p>When a view is backed by a hardware layer, some of its properties are handled by the way the layer is composited on screen. Setting these properties will be efficient because they do not require the view to be invalidated and redrawn. The following list of properties affect the way the layer is composited. Calling the setter for any of these properties results in optimal invalidation and no redrawing of the targeted view:</p> 
 <ul> 
  <li><code>alpha</code>: Changes the layer's opacity</li> 
  <li><code>x</code>, <code>y</code>, <code>translationX</code>, <code>translationY</code>: Changes the layer's position</li> 
  <li><code>scaleX</code>, <code>scaleY</code>: Changes the layer's size</li> 
  <li><code>rotation</code>, <code>rotationX</code>, <code>rotationY</code>: Changes the layer's orientation in 3D space</li> 
  <li><code>pivotX</code>, <code>pivotY</code>: Changes the layer's transformations origin</li> 
 </ul> 
 <p>These properties are the names used when animating a view with an <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>. If you want to access these properties, call the appropriate setter or getter. For instance, to modify the alpha property, call <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code>. The following code snippet shows the most efficient way to rotate a viewiew in 3D around the Y-axis:</p> 
 <pre>
view.setLayerType(View.LAYER_TYPE_HARDWARE, null);
ObjectAnimator.ofFloat(view, &quot;rotationY&quot;, 180).start();
</pre> 
 <p>Because hardware layers consume video memory, it is highly recommended that you enable them only for the duration of the animation and then disable them after the animation is done. You can accomplish this using animation listeners:</p> 
 <pre>
View.setLayerType(View.LAYER_TYPE_HARDWARE, null);
ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;rotationY&quot;, 180);
animator.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator animation) {
        view.setLayerType(View.LAYER_TYPE_NONE, null);
    }
});
animator.start();
</pre> 
 <p>For more information on property animation, see <a href="../../../guide/topics/graphics/prop-animation.html">Property Animation</a>.</p> 
 ","ObjectAnimator","android.animation.ObjectAnimator","class",1
,"Hardware Acceleration","Tips and Tricks","<h2 id="tips">Tips and Tricks</h2> 
 <p>Switching to hardware accelerated 2D graphics can instantly increase performance, but you should still design your application to use the GPU effectively by following these recommendations:</p> 
 <dl> 
  <dt>
   <strong>Reduce the number of views in your application</strong>
  </dt> 
  <dd>
   The more views the system has to draw, the slower it will be. This applies to the software rendering pipeline as well. Reducing views is one of the easiest ways to optimize your UI.
  </dd> 
  <dt>
   <strong>Avoid overdraw</strong>
  </dt> 
  <dd>
   Do not draw too many layers on top of each other. Remove any views that are completely obscured by other opaque views on top of it. If you need to draw several layers blended on top of each other, consider merging them into a single layer. A good rule of thumb with current hardware is to not draw more than 2.5 times the number of pixels on screen per frame (transparent pixels in a bitmap count!).
  </dd> 
  <dt>
   <strong>Don't create render objects in draw methods</strong>
  </dt> 
  <dd>
   A common mistake is to create a new 
   <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> or a new 
   <code><a href="../../../reference/android/graphics/Path.html">Path</a></code> every time a rendering method is invoked. This forces the garbage collector to run more often and also bypasses caches and optimizations in the hardware pipeline.
  </dd> 
  <dt>
   <strong>Don't modify shapes too often</strong>
  </dt> 
  <dd>
   Complex shapes, paths, and circles for instance, are rendered using texture masks. Every time you create or modify a path, the hardware pipeline creates a new mask, which can be expensive.
  </dd> 
  <dt>
   <strong>Don't modify bitmaps too often</strong>
  </dt> 
  <dd>
   Every time you change the content of a bitmap, it is uploaded again as a GPU texture the next time you draw it.
  </dd> 
  <dt>
   <strong>Use alpha with care</strong>
  </dt> 
  <dd>
   When you make a view translucent using 
   <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code>, 
   <code><a href="../../../reference/android/view/animation/AlphaAnimation.html">AlphaAnimation</a></code>, or 
   <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, it is rendered in an off-screen buffer which doubles the required fill-rate. When applying alpha on very large views, consider setting the view's layer type to 
   <code>LAYER_TYPE_HARDWARE</code>.
  </dd> 
 </dl> 
</div> 
","ObjectAnimator","android.animation.ObjectAnimator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","ObjectAnimator","android.animation.ObjectAnimator","class",1
,"Property Animation","Animating with ObjectAnimator","<h2 id="object-animator">Animating with ObjectAnimator</h2> 
 <p>The <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> is a subclass of the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> (discussed in the previous section) and combines the timing engine and value computation of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> with the ability to animate a named property of a target object. This makes animating any object much easier, as you no longer need to implement the <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html">ValueAnimator.AnimatorUpdateListener</a></code>, because the animated property updates automatically.</p> 
 <p>Instantiating an <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> is similar to a <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>, but you also specify the object and the name of that object's property (as a String) along with the values to animate between:</p> 
 <pre>
ObjectAnimator anim = ObjectAnimator.ofFloat(foo, &quot;alpha&quot;, 0f, 1f);
anim.setDuration(1000);
anim.start();
</pre> 
 <p>To have the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> update properties correctly, you must do the following:</p> 
 <ul> 
  <li>The object property that you are animating must have a setter function (in camel case) in the form of <code>set&lt;propertyName&gt;()</code>. Because the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> automatically updates the property during animation, it must be able to access the property with this setter method. For example, if the property name is <code>foo</code>, you need to have a <code>setFoo()</code> method. If this setter method does not exist, you have three options: 
   <ul> 
    <li>Add the setter method to the class if you have the rights to do so.</li> 
    <li>Use a wrapper class that you have rights to change and have that wrapper receive the value with a valid setter method and forward it to the original object.</li> 
    <li>Use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> instead.</li> 
   </ul> </li> 
  <li>If you specify only one value for the <code>values...</code> parameter in one of the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> factory methods, it is assumed to be the ending value of the animation. Therefore, the object property that you are animating must have a getter function that is used to obtain the starting value of the animation. The getter function must be in the form of <code>get&lt;propertyName&gt;()</code>. For example, if the property name is <code>foo</code>, you need to have a <code>getFoo()</code> method.</li> 
  <li>The getter (if needed) and setter methods of the property that you are animating must operate on the same type as the starting and ending values that you specify to <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>. For example, you must have <code>targetObject.setPropName(float)</code> and <code>targetObject.getPropName(float)</code> if you construct the following <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>: <pre>
ObjectAnimator.ofFloat(targetObject, &quot;propName&quot;, 1f)
</pre> </li> 
  <li>Depending on what property or object you are animating, you might need to call the <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> method on a View to force the screen to redraw itself with the updated animated values. You do this in the <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> callback. For example, animating the color property of a Drawable object only cause updates to the screen when that object redraws itself. All of the property setters on View, such as <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code> and <code><a href="../../../reference/android/view/View.html#setTranslationX(float)">setTranslationX()</a></code> invalidate the View properly, so you do not need to invalidate the View when calling these methods with new values. For more information on listeners, see the section about <a href="#listeners">Animation Listeners</a>. </li> 
 </ul> 
 ","ObjectAnimator","android.animation.ObjectAnimator","class",1
,"Property Animation","Using a TypeEvaluator","<h2 id="type-evaluator">Using a TypeEvaluator</h2> 
 <p>If you want to animate a type that is unknown to the Android system, you can create your own evaluator by implementing the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface. The types that are known by the Android system are <code>int</code>, <code>float</code>, or a color, which are supported by the <code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code>, <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code>, and <code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code> type evaluators.</p> 
 <p>There is only one method to implement in the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface, the <code><a href="../../../reference/android/animation/TypeEvaluator.html#evaluate(float, T, T)">evaluate()</a></code> method. This allows the animator that you are using to return an appropriate value for your animated property at the current point of the animation. The <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code> class demonstrates how to do this:</p> 
 <pre>
public class FloatEvaluator implements TypeEvaluator {

    public Object evaluate(float fraction, Object startValue, Object endValue) {
        float startFloat = ((Number) startValue).floatValue();
        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);
    }
}
</pre> 
 <p class="note"><strong>Note:</strong> When <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> (or <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>) runs, it calculates a current elapsed fraction of the animation (a value between 0 and 1) and then calculates an interpolated version of that depending on what interpolator that you are using. The interpolated fraction is what your <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> receives through the <code>fraction</code> parameter, so you do not have to take into account the interpolator when calculating animated values.</p> 
 ","ObjectAnimator","android.animation.ObjectAnimator","class",0
,"Animating Views","Animating with ViewPropertyAnimator","<h3 id="view-prop-animator">Animating with ViewPropertyAnimator</h3> 
 <p>The <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> provides a simple way to animate several properties of a <code><a href="../../../reference/android/view/View.html">View</a></code> in parallel, using a single underlying <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> object. It behaves much like an <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, because it modifies the actual values of the view's properties, but is more efficient when animating many properties at once. In addition, the code for using the <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> is much more concise and easier to read. The following code snippets show the differences in using multiple <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> objects, a single <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, and the <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> when simultaneously animating the <code>x</code> and <code>y</code> property of a view.</p> 
 <p><strong>Multiple ObjectAnimator objects</strong></p> 
 <pre>
ObjectAnimator animX = ObjectAnimator.ofFloat(myView, &quot;x&quot;, 50f);
ObjectAnimator animY = ObjectAnimator.ofFloat(myView, &quot;y&quot;, 100f);
AnimatorSet animSetXY = new AnimatorSet();
animSetXY.playTogether(animX, animY);
animSetXY.start();
</pre> 
 <p><strong>One ObjectAnimator</strong></p> 
 <pre>
PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(&quot;x&quot;, 50f);
PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(&quot;y&quot;, 100f);
ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();
</pre> 
 <p><strong>ViewPropertyAnimator</strong></p> 
 <pre>
myView.animate().x(50f).y(100f);
</pre> 
 <p> For more detailed information about <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code>, see the corresponding Android Developers <a href="http://android-developers.blogspot.com/2011/05/introducing-viewpropertyanimator.html">blog post</a>.</p> 
 ","ObjectAnimator","android.animation.ObjectAnimator","class",0
,"Property Animation","Declaring Animations in XML","<h2 id="declaring-xml">Declaring Animations in XML</h2> 
 <p>The property animation system lets you declare property animations with XML instead of doing it programmatically. By defining your animations in XML, you can easily reuse your animations in multiple activities and more easily edit the animation sequence.</p> 
 <p>To distinguish animation files that use the new property animation APIs from those that use the legacy <a href="../../../guide/topics/graphics/view-animation.html">view animation</a> framework, starting with Android 3.1, you should save the XML files for property animations in the <code>res/animator/</code> directory (instead of <code>res/anim/</code>). Using the <code>animator</code> directory name is optional, but necessary if you want to use the layout editor tools in the Eclipse ADT plugin (ADT 11.0.0+), because ADT only searches the <code>res/animator/</code> directory for property animation resources.</p> 
 <p>The following property animation classes have XML declaration support with the following XML tags:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> - <code>&lt;animator&gt;</code></li> 
  <li><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> - <code>&lt;objectAnimator&gt;</code></li> 
  <li><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> - <code>&lt;set&gt;</code></li> 
 </ul> 
 <p>The following example plays the two sets of object animations sequentially, with the first nested set playing two object animations together:</p> 
 <pre>
&lt;set android:ordering=&quot;sequentially&quot;&gt;
    &lt;set&gt;
        &lt;objectAnimator
            android:propertyName=&quot;x&quot;
            android:duration=&quot;500&quot;
            android:valueTo=&quot;400&quot;
            android:valueType=&quot;intType&quot;/&gt;
        &lt;objectAnimator
            android:propertyName=&quot;y&quot;
            android:duration=&quot;500&quot;
            android:valueTo=&quot;300&quot;
            android:valueType=&quot;intType&quot;/&gt;
    &lt;/set&gt;
    &lt;objectAnimator
        android:propertyName=&quot;alpha&quot;
        android:duration=&quot;500&quot;
        android:valueTo=&quot;1f&quot;/&gt;
&lt;/set&gt;
</pre> 
 <p>In order to run this animation, you must inflate the XML resources in your code to an <code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> object, and then set the target objects for all of the animations before starting the animation set. Calling <code><a href="../../../reference/android/animation/AnimatorSet.html#setTarget(java.lang.Object)">setTarget()</a></code> sets a single target object for all children of the <code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> as a convenience. The following code shows how to do this:</p> 
 <pre>
AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,
    R.anim.property_animator);
set.setTarget(myObject);
set.start();
</pre> 
 <p>For information about the XML syntax for defining property animations, see <a href="../../../guide/topics/resources/animation-resource.html#Property">Animation Resources</a>. </p>
</div> 
","ObjectAnimator","android.animation.ObjectAnimator","class",0
,"Hardware Acceleration","Tips and Tricks","<h2 id="tips">Tips and Tricks</h2> 
 <p>Switching to hardware accelerated 2D graphics can instantly increase performance, but you should still design your application to use the GPU effectively by following these recommendations:</p> 
 <dl> 
  <dt>
   <strong>Reduce the number of views in your application</strong>
  </dt> 
  <dd>
   The more views the system has to draw, the slower it will be. This applies to the software rendering pipeline as well. Reducing views is one of the easiest ways to optimize your UI.
  </dd> 
  <dt>
   <strong>Avoid overdraw</strong>
  </dt> 
  <dd>
   Do not draw too many layers on top of each other. Remove any views that are completely obscured by other opaque views on top of it. If you need to draw several layers blended on top of each other, consider merging them into a single layer. A good rule of thumb with current hardware is to not draw more than 2.5 times the number of pixels on screen per frame (transparent pixels in a bitmap count!).
  </dd> 
  <dt>
   <strong>Don't create render objects in draw methods</strong>
  </dt> 
  <dd>
   A common mistake is to create a new 
   <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> or a new 
   <code><a href="../../../reference/android/graphics/Path.html">Path</a></code> every time a rendering method is invoked. This forces the garbage collector to run more often and also bypasses caches and optimizations in the hardware pipeline.
  </dd> 
  <dt>
   <strong>Don't modify shapes too often</strong>
  </dt> 
  <dd>
   Complex shapes, paths, and circles for instance, are rendered using texture masks. Every time you create or modify a path, the hardware pipeline creates a new mask, which can be expensive.
  </dd> 
  <dt>
   <strong>Don't modify bitmaps too often</strong>
  </dt> 
  <dd>
   Every time you change the content of a bitmap, it is uploaded again as a GPU texture the next time you draw it.
  </dd> 
  <dt>
   <strong>Use alpha with care</strong>
  </dt> 
  <dd>
   When you make a view translucent using 
   <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code>, 
   <code><a href="../../../reference/android/view/animation/AlphaAnimation.html">AlphaAnimation</a></code>, or 
   <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, it is rendered in an off-screen buffer which doubles the required fill-rate. When applying alpha on very large views, consider setting the view's layer type to 
   <code>LAYER_TYPE_HARDWARE</code>.
  </dd> 
 </dl> 
</div> 
","Path","android.graphics.Path","class",0
,"Hardware Acceleration","Tips and Tricks","<h2 id="tips">Tips and Tricks</h2> 
 <p>Switching to hardware accelerated 2D graphics can instantly increase performance, but you should still design your application to use the GPU effectively by following these recommendations:</p> 
 <dl> 
  <dt>
   <strong>Reduce the number of views in your application</strong>
  </dt> 
  <dd>
   The more views the system has to draw, the slower it will be. This applies to the software rendering pipeline as well. Reducing views is one of the easiest ways to optimize your UI.
  </dd> 
  <dt>
   <strong>Avoid overdraw</strong>
  </dt> 
  <dd>
   Do not draw too many layers on top of each other. Remove any views that are completely obscured by other opaque views on top of it. If you need to draw several layers blended on top of each other, consider merging them into a single layer. A good rule of thumb with current hardware is to not draw more than 2.5 times the number of pixels on screen per frame (transparent pixels in a bitmap count!).
  </dd> 
  <dt>
   <strong>Don't create render objects in draw methods</strong>
  </dt> 
  <dd>
   A common mistake is to create a new 
   <code><a href="../../../reference/android/graphics/Paint.html">Paint</a></code> or a new 
   <code><a href="../../../reference/android/graphics/Path.html">Path</a></code> every time a rendering method is invoked. This forces the garbage collector to run more often and also bypasses caches and optimizations in the hardware pipeline.
  </dd> 
  <dt>
   <strong>Don't modify shapes too often</strong>
  </dt> 
  <dd>
   Complex shapes, paths, and circles for instance, are rendered using texture masks. Every time you create or modify a path, the hardware pipeline creates a new mask, which can be expensive.
  </dd> 
  <dt>
   <strong>Don't modify bitmaps too often</strong>
  </dt> 
  <dd>
   Every time you change the content of a bitmap, it is uploaded again as a GPU texture the next time you draw it.
  </dd> 
  <dt>
   <strong>Use alpha with care</strong>
  </dt> 
  <dd>
   When you make a view translucent using 
   <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code>, 
   <code><a href="../../../reference/android/view/animation/AlphaAnimation.html">AlphaAnimation</a></code>, or 
   <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, it is rendered in an off-screen buffer which doubles the required fill-rate. When applying alpha on very large views, consider setting the view's layer type to 
   <code>LAYER_TYPE_HARDWARE</code>.
  </dd> 
 </dl> 
</div> 
","AlphaAnimation","android.view.animation.AlphaAnimation","class",0
,"OpenGL ES","The Basics","<h2 id="basics">The Basics</h2> 
 <p>Android supports OpenGL both through its framework API and the Native Development Kit (NDK). This topic focuses on the Android framework interfaces. For more information about the NDK, see the <a href="../../../tools/sdk/ndk/index.html">Android NDK</a>. </p>
 <p>There are two foundational classes in the Android framework that let you create and manipulate graphics with the OpenGL ES API: <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>. If your goal is to use OpenGL in your Android application, understanding how to implement these classes in an activity should be your first objective. </p> 
 <dl> 
  <dt>
   <strong><code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code></strong>
  </dt> 
  <dd>
   This class is a 
   <code><a href="../../../reference/android/view/View.html">View</a></code> where you can draw and manipulate objects using OpenGL API calls and is similar in function to a 
   <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code>. You can use this class by creating an instance of 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and adding your 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">Renderer</a></code> to it. However, if you want to capture touch screen events, you should extend the 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> class to implement the touch listeners, as shown in OpenGL training lesson, 
   <a href="../../../training/graphics/opengl/touch.html">Responding to Touch Events</a>.
  </dd> 
  <dt>
   <strong><code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code></strong>
  </dt> 
  <dd>
   This interface defines the methods required for drawing graphics in a 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. You must provide an implementation of this interface as a separate class and attach it to your 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> instance using 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html#setRenderer(android.opengl.GLSurfaceView.Renderer)">GLSurfaceView.setRenderer()</a></code>. 
   <p>The <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> interface requires that you implement the following methods:</p> 
   <ul> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceCreated(javax.microedition.khronos.opengles.GL10, javax.microedition.khronos.egl.EGLConfig)">onSurfaceCreated()</a></code>: The system calls this method once, when creating the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. Use this method to perform actions that need to happen only once, such as setting OpenGL environment parameters or initializing OpenGL graphic objects. </li> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onDrawFrame(javax.microedition.khronos.opengles.GL10)">onDrawFrame()</a></code>: The system calls this method on each redraw of the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. Use this method as the primary execution point for drawing (and re-drawing) graphic objects.</li> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)">onSurfaceChanged()</a></code>: The system calls this method when the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> geometry changes, including changes in size of the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> or orientation of the device screen. For example, the system calls this method when the device changes from portrait to landscape orientation. Use this method to respond to changes in the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> container. </li> 
   </ul> 
  </dd> 
 </dl> 
 ","GLSurfaceView","android.opengl.GLSurfaceView","class",0
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GLSurfaceView","android.opengl.GLSurfaceView","class",0
,"OpenGL ES","The Basics","<h2 id="basics">The Basics</h2> 
 <p>Android supports OpenGL both through its framework API and the Native Development Kit (NDK). This topic focuses on the Android framework interfaces. For more information about the NDK, see the <a href="../../../tools/sdk/ndk/index.html">Android NDK</a>. </p>
 <p>There are two foundational classes in the Android framework that let you create and manipulate graphics with the OpenGL ES API: <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>. If your goal is to use OpenGL in your Android application, understanding how to implement these classes in an activity should be your first objective. </p> 
 <dl> 
  <dt>
   <strong><code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code></strong>
  </dt> 
  <dd>
   This class is a 
   <code><a href="../../../reference/android/view/View.html">View</a></code> where you can draw and manipulate objects using OpenGL API calls and is similar in function to a 
   <code><a href="../../../reference/android/view/SurfaceView.html">SurfaceView</a></code>. You can use this class by creating an instance of 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and adding your 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">Renderer</a></code> to it. However, if you want to capture touch screen events, you should extend the 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> class to implement the touch listeners, as shown in OpenGL training lesson, 
   <a href="../../../training/graphics/opengl/touch.html">Responding to Touch Events</a>.
  </dd> 
  <dt>
   <strong><code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code></strong>
  </dt> 
  <dd>
   This interface defines the methods required for drawing graphics in a 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. You must provide an implementation of this interface as a separate class and attach it to your 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> instance using 
   <code><a href="../../../reference/android/opengl/GLSurfaceView.html#setRenderer(android.opengl.GLSurfaceView.Renderer)">GLSurfaceView.setRenderer()</a></code>. 
   <p>The <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> interface requires that you implement the following methods:</p> 
   <ul> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceCreated(javax.microedition.khronos.opengles.GL10, javax.microedition.khronos.egl.EGLConfig)">onSurfaceCreated()</a></code>: The system calls this method once, when creating the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. Use this method to perform actions that need to happen only once, such as setting OpenGL environment parameters or initializing OpenGL graphic objects. </li> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onDrawFrame(javax.microedition.khronos.opengles.GL10)">onDrawFrame()</a></code>: The system calls this method on each redraw of the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code>. Use this method as the primary execution point for drawing (and re-drawing) graphic objects.</li> 
    <li> <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)">onSurfaceChanged()</a></code>: The system calls this method when the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> geometry changes, including changes in size of the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> or orientation of the device screen. For example, the system calls this method when the device changes from portrait to landscape orientation. Use this method to respond to changes in the <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> container. </li> 
   </ul> 
  </dd> 
 </dl> 
 ","Renderer","android.opengl.GLSurfaceView.Renderer","class",0
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","Renderer","android.opengl.GLSurfaceView.Renderer","class",0
,"Mapping Coordinates for Drawn Objects","Projection and camera view in OpenGL ES 1.0","<h3 id="proj-es1">Projection and camera view in OpenGL ES 1.0</h3> 
 <p>In the ES 1.0 API, you apply projection and camera view by creating each matrix and then adding them to the OpenGL environment.</p> 
 <ol> 
  <li><strong>Projection matrix</strong> - Create a projection matrix using the geometry of the device screen in order to recalculate object coordinates so they are drawn with correct proportions. The following example code demonstrates how to modify the <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)">onSurfaceChanged()</a></code> method of a <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> implementation to create a projection matrix based on the screen's aspect ratio and apply it to the OpenGL rendering environment. <pre>
public void onSurfaceChanged(GL10 gl, int width, int height) {
    gl.glViewport(0, 0, width, height);

    // make adjustments for screen ratio
    float ratio = (float) width / height;
    gl.glMatrixMode(GL10.GL_PROJECTION);        // set matrix to projection mode
    gl.glLoadIdentity();                        // reset the matrix to its default state
    gl.glFrustumf(-ratio, ratio, -1, 1, 3, 7);  // apply the projection matrix
}
</pre> </li> 
  <li><strong>Camera transformation matrix</strong> - Once you have adjusted the coordinate system using a projection matrix, you must also apply a camera view. The following example code shows how to modify the <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onDrawFrame(javax.microedition.khronos.opengles.GL10)">onDrawFrame()</a></code> method of a <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> implementation to apply a model view and use the <code><a href="../../../reference/android/opengl/GLU.html#gluLookAt(javax.microedition.khronos.opengles.GL10, float, float, float, float, float, float, float, float, float)">GLU.gluLookAt()</a></code> utility to create a viewing tranformation which simulates a camera position. <pre>
public void onDrawFrame(GL10 gl) {
    ...
    // Set GL_MODELVIEW transformation mode
    gl.glMatrixMode(GL10.GL_MODELVIEW);
    gl.glLoadIdentity();                      // reset the matrix to its default state

    // When using GL_MODELVIEW, you must set the camera view
    GLU.gluLookAt(gl, 0, 0, -5, 0f, 0f, 0f, 0f, 1.0f, 0.0f);
    ...
}
</pre> </li> 
 </ol> 
 ","Renderer","android.opengl.GLSurfaceView.Renderer","class",1
,"Mapping Coordinates for Drawn Objects","Projection and camera view in OpenGL ES 2.0 and higher","<h3 id="proj-es2">Projection and camera view in OpenGL ES 2.0 and higher</h3> 
 <p>In the ES 2.0 and 3.0 APIs, you apply projection and camera view by first adding a matrix member to the vertex shaders of your graphics objects. With this matrix member added, you can then generate and apply projection and camera viewing matrices to your objects.</p> 
 <ol> 
  <li><strong>Add matrix to vertex shaders</strong> - Create a variable for the view projection matrix and include it as a multiplier of the shader's position. In the following example vertex shader code, the included <code>uMVPMatrix</code> member allows you to apply projection and camera viewing matrices to the coordinates of objects that use this shader. <pre>
private final String vertexShaderCode =

    // This matrix member variable provides a hook to manipulate
    // the coordinates of objects that use this vertex shader.
    &quot;uniform mat4 uMVPMatrix;   \n&quot; +

    &quot;attribute vec4 vPosition;  \n&quot; +
    &quot;void main(){               \n&quot; +
    // The matrix must be included as part of gl_Position
    // Note that the uMVPMatrix factor *must be first* in order
    // for the matrix multiplication product to be correct.
    &quot; gl_Position = uMVPMatrix * vPosition; \n&quot; +

    &quot;}  \n&quot;;
</pre> <p class="note"><strong>Note:</strong> The example above defines a single transformation matrix member in the vertex shader into which you apply a combined projection matrix and camera view matrix. Depending on your application requirements, you may want to define separate projection matrix and camera viewing matrix members in your vertex shaders so you can change them independently.</p> </li> 
  <li><strong>Access the shader matrix</strong> - After creating a hook in your vertex shaders to apply projection and camera view, you can then access that variable to apply projection and camera viewing matrices. The following code shows how to modify the <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceCreated(javax.microedition.khronos.opengles.GL10, javax.microedition.khronos.egl.EGLConfig)">onSurfaceCreated()</a></code> method of a <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> implementation to access the matrix variable defined in the vertex shader above. <pre>
public void onSurfaceCreated(GL10 unused, EGLConfig config) {
    ...
    muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, &quot;uMVPMatrix&quot;);
    ...
}
</pre> </li> 
  <li><strong>Create projection and camera viewing matrices</strong> - Generate the projection and viewing matrices to be applied the graphic objects. The following example code shows how to modify the <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceCreated(javax.microedition.khronos.opengles.GL10, javax.microedition.khronos.egl.EGLConfig)">onSurfaceCreated()</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)">onSurfaceChanged()</a></code> methods of a <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> implementation to create camera view matrix and a projection matrix based on the screen aspect ratio of the device. <pre>
public void onSurfaceCreated(GL10 unused, EGLConfig config) {
    ...
    // Create a camera view matrix
    Matrix.setLookAtM(mVMatrix, 0, 0, 0, -3, 0f, 0f, 0f, 0f, 1.0f, 0.0f);
}

public void onSurfaceChanged(GL10 unused, int width, int height) {
    GLES20.glViewport(0, 0, width, height);

    float ratio = (float) width / height;

    // create a projection matrix from device screen geometry
    Matrix.frustumM(mProjMatrix, 0, -ratio, ratio, -1, 1, 3, 7);
}
</pre> </li> 
  <li><strong>Apply projection and camera viewing matrices</strong> - To apply the projection and camera view transformations, multiply the matrices together and then set them into the vertex shader. The following example code shows how modify the <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onDrawFrame(javax.microedition.khronos.opengles.GL10)">onDrawFrame()</a></code> method of a <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> implementation to combine the projection matrix and camera view created in the code above and then apply it to the graphic objects to be rendered by OpenGL. <pre>
public void onDrawFrame(GL10 unused) {
    ...
    // Combine the projection and camera view matrices
    Matrix.multiplyMM(mMVPMatrix, 0, mProjMatrix, 0, mVMatrix, 0);

    // Apply the combined projection and camera view transformations
    GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, mMVPMatrix, 0);

    // Draw objects
    ...
}
</pre> </li> 
 </ol> 
 <p>For a complete example of how to apply projection and camera view with OpenGL ES 2.0, see the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class.</p> 
 ","Renderer","android.opengl.GLSurfaceView.Renderer","class",0
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","package-summary","android.opengl.package-summary","class",1
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GLES10","android.opengl.GLES10","class",0
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GLES11","android.opengl.GLES11","class",0
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GLES30","android.opengl.GLES30","class",1
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GLES20","android.opengl.GLES20","class",1
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GL10","javax.microedition.khronos.opengles.GL10","class",0
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GL11Ext","javax.microedition.khronos.opengles.GL11Ext","class",0
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GL10Ext","javax.microedition.khronos.opengles.GL10Ext","class",0
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GL11ExtensionPack","javax.microedition.khronos.opengles.GL11ExtensionPack","class",0
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","package-summary","javax.microedition.khronos.opengles.package-summary","class",1
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GLES10Ext","android.opengl.GLES10Ext","class",0
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GLES11Ext","android.opengl.GLES11Ext","class",0
,"The Basics","OpenGL ES packages","<h3 id="packages">OpenGL ES packages</h3> 
 <p>Once you have established a container view for OpenGL ES using <code><a href="../../../reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a></code> and <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code>, you can begin calling OpenGL APIs using the following classes:</p> 
 <ul> 
  <li>OpenGL ES 1.0/1.1 API Packages 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/package-summary.html">android.opengl</a></code> - This package provides a static interface to the OpenGL ES 1.0/1.1 classes and better performance than the <code>javax.microedition.khronos</code> package interfaces. 
     <ul> 
      <li><code><a href="../../../reference/android/opengl/GLES10.html">GLES10</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES10Ext.html">GLES10Ext</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11.html">GLES11</a></code></li> 
      <li><code><a href="../../../reference/android/opengl/GLES11Ext.html">GLES11Ext</a></code></li> 
     </ul> </li> 
    <li><code><a href="../../../reference/javax/microedition/khronos/opengles/package-summary.html">javax.microedition.khronos.opengles</a></code> - This package provides the standard implementation of OpenGL ES 1.0/1.1. 
     <ul> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10.html">GL10</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL10Ext.html">GL10Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11.html">GL11</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11Ext.html">GL11Ext</a></code></li> 
      <li><code><a href="../../../reference/javax/microedition/khronos/opengles/GL11ExtensionPack.html">GL11ExtensionPack</a></code></li> 
     </ul> </li> 
   </ul> </li> 
  <li>OpenGL ES 2.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES20.html">android.opengl.GLES20</a></code> - This package provides the interface to OpenGL ES 2.0 and is available starting with Android 2.2 (API level 8).</li> 
   </ul> </li> 
  <li>OpenGL ES 3.0 API Class 
   <ul> 
    <li><code><a href="../../../reference/android/opengl/GLES30.html">android.opengl.GLES30</a></code> - This package provides the interface to OpenGL ES 3.0 and is available starting with Android 4.3 (API level 18).</li> 
   </ul> </li> 
 </ul> 
 <p>If you want to start building an app with OpenGL ES right away, follow the <a href="../../../training/graphics/opengl/index.html">Displaying Graphics with OpenGL ES</a> class. </p> 
 ","GL11","javax.microedition.khronos.opengles.GL11","class",0
,"Mapping Coordinates for Drawn Objects","Projection and camera view in OpenGL ES 1.0","<h3 id="proj-es1">Projection and camera view in OpenGL ES 1.0</h3> 
 <p>In the ES 1.0 API, you apply projection and camera view by creating each matrix and then adding them to the OpenGL environment.</p> 
 <ol> 
  <li><strong>Projection matrix</strong> - Create a projection matrix using the geometry of the device screen in order to recalculate object coordinates so they are drawn with correct proportions. The following example code demonstrates how to modify the <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)">onSurfaceChanged()</a></code> method of a <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> implementation to create a projection matrix based on the screen's aspect ratio and apply it to the OpenGL rendering environment. <pre>
public void onSurfaceChanged(GL10 gl, int width, int height) {
    gl.glViewport(0, 0, width, height);

    // make adjustments for screen ratio
    float ratio = (float) width / height;
    gl.glMatrixMode(GL10.GL_PROJECTION);        // set matrix to projection mode
    gl.glLoadIdentity();                        // reset the matrix to its default state
    gl.glFrustumf(-ratio, ratio, -1, 1, 3, 7);  // apply the projection matrix
}
</pre> </li> 
  <li><strong>Camera transformation matrix</strong> - Once you have adjusted the coordinate system using a projection matrix, you must also apply a camera view. The following example code shows how to modify the <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html#onDrawFrame(javax.microedition.khronos.opengles.GL10)">onDrawFrame()</a></code> method of a <code><a href="../../../reference/android/opengl/GLSurfaceView.Renderer.html">GLSurfaceView.Renderer</a></code> implementation to apply a model view and use the <code><a href="../../../reference/android/opengl/GLU.html#gluLookAt(javax.microedition.khronos.opengles.GL10, float, float, float, float, float, float, float, float, float)">GLU.gluLookAt()</a></code> utility to create a viewing tranformation which simulates a camera position. <pre>
public void onDrawFrame(GL10 gl) {
    ...
    // Set GL_MODELVIEW transformation mode
    gl.glMatrixMode(GL10.GL_MODELVIEW);
    gl.glLoadIdentity();                      // reset the matrix to its default state

    // When using GL_MODELVIEW, you must set the camera view
    GLU.gluLookAt(gl, 0, 0, -5, 0f, 0f, 0f, 0f, 1.0f, 0.0f);
    ...
}
</pre> </li> 
 </ol> 
 ","GLU","android.opengl.GLU","class",0
,"OpenGL Versions and Device Compatibility","Texture compression support","<h3 id="textures">Texture compression support</h3> 
 <p>Texture compression can significantly increase the performance of your OpenGL application by reducing memory requirements and making more efficient use of memory bandwidth. The Android framework provides support for the ETC1 compression format as a standard feature, including a <code><a href="../../../reference/android/opengl/ETC1Util.html">ETC1Util</a></code> utility class and the <code>etc1tool</code> compression tool (located in the Android SDK at <code>&lt;sdk&gt;/tools/</code>). For an example of an Android application that uses texture compression, see the <code>CompressedTextureActivity</code> code sample in Android SDK (<code>&lt;sdk&gt;/samples/&lt;version&gt;/ApiDemos/src/com/example/android/apis/graphics/</code>).</p> 
 <p class="caution"><strong>Caution:</strong> The ETC1 format is supported by most Android devices, but it not guaranteed to be available. To check if the ETC1 format is supported on a device, call the <code><a href="../../../reference/android/opengl/ETC1Util.html#isETC1Supported()">ETC1Util.isETC1Supported()</a></code> method.</p> 
 <p class="note"><b>Note:</b> The ETC1 texture compression format does not support textures with an transparency (alpha channel). If your application requires textures with transparency, you should investigate other texture compression formats available on your target devices.</p> 
 <p>The ETC2/EAC texture compression formats are guaranteed to be available when using the OpenGL ES 3.0 API. This texture format offers excellent compression ratios with high visual quality and the format also supports transparency (alpha channel).</p> 
 <p>Beyond the ETC formats, Android devices have varied support for texture compression based on their GPU chipsets and OpenGL implementations. You should investigate texture compression support on the devices you are are targeting to determine what compression types your application should support. In order to determine what texture formats are supported on a given device, you must <a href="#gl-extension-query">query the device</a> and review the <em>OpenGL extension names</em>, which identify what texture compression formats (and other OpenGL features) are supported by the device. Some commonly supported texture compression formats are as follows:</p> 
 <ul> 
  <li><strong>ATITC (ATC)</strong> - ATI texture compression (ATITC or ATC) is available on a wide variety of devices and supports fixed rate compression for RGB textures with and without an alpha channel. This format may be represented by several OpenGL extension names, for example: 
   <ul> 
    <li><code>GL_AMD_compressed_ATC_texture</code></li> 
    <li><code>GL_ATI_texture_compression_atitc</code></li> 
   </ul> </li> 
  <li><strong>PVRTC</strong> - PowerVR texture compression (PVRTC) is available on a wide variety of devices and supports 2-bit and 4-bit per pixel textures with or without an alpha channel. This format is represented by the following OpenGL extension name: 
   <ul> 
    <li><code>GL_IMG_texture_compression_pvrtc</code></li> 
   </ul> </li> 
  <li><strong>S3TC (DXT<em>n</em>/DXTC)</strong> - S3 texture compression (S3TC) has several format variations (DXT1 to DXT5) and is less widely available. The format supports RGB textures with 4-bit alpha or 8-bit alpha channels. This format may be represented by several OpenGL extension names, for example: 
   <ul> 
    <li><code>GL_OES_texture_compression_S3TC</code></li> 
    <li><code>GL_EXT_texture_compression_s3tc</code></li> 
    <li><code>GL_EXT_texture_compression_dxt1</code></li> 
    <li><code>GL_EXT_texture_compression_dxt3</code></li> 
    <li><code>GL_EXT_texture_compression_dxt5</code></li> 
   </ul> </li> 
  <li><strong>3DC</strong> - 3DC texture compression (3DC) is a less widely available format that supports RGB textures with an alpha channel. This format is represented by the following OpenGL extension name: 
   <ul> 
    <li><code>GL_AMD_compressed_3DC_texture</code></li> 
   </ul> </li> 
 </ul> 
 <p class="warning"><strong>Warning:</strong> These texture compression formats are <em>not supported</em> on all devices. Support for these formats can vary by manufacturer and device. For information on how to determine what texture compression formats are on a particular device, see the next section. </p> 
 <p class="note"><strong>Note:</strong> Once you decide which texture compression formats your application will support, make sure you declare them in your manifest using <a href="../../../guide/topics/manifest/supports-gl-texture-element.html">&lt;supports-gl-texture&gt; </a>. Using this declaration enables filtering by external services such as Google Play, so that your app is installed only on devices that support the formats your app requires. For details, see <a href="../../../guide/topics/graphics/opengl.html#manifest">OpenGL manifest declarations</a>.</p> 
 ","ETC1Util","android.opengl.ETC1Util","class",0
,"OpenGL Versions and Device Compatibility","Checking OpenGL ES Version","<h3 id="version-check">Checking OpenGL ES Version</h3> 
 <p>There are several versions of the OpenGL ES available on Android devices. You can specify the minimum version of the API your application requires in your <a href="#manifest">manifest</a>, but you may also want to take advantage of features in a newer API at the same time. For example, the OpenGL ES 3.0 API is backward-compatible with the 2.0 version of the API, so you may want to write your application so that it uses OpenGL ES 3.0 features, but falls back to the 2.0 API if the 3.0 API is not available.</p> 
 <p>Before using OpenGL ES features from a version higher than the minimum required in your application manifest, your application should check the version of the API available on the device. You can do this in one of two ways:</p> 
 <ol> 
  <li>Attempt create the higher-level OpenGL ES context (<code><a href="../../../reference/android/opengl/EGLContext.html">EGLContext</a></code>) and check the result.</li> 
  <li>Create a minimum-supported OpenGL ES context and check the version value.</li> 
 </ol> 
 <p>The following example code demonstrates how to check the available OpenGL ES version by creating an <code><a href="../../../reference/android/opengl/EGLContext.html">EGLContext</a></code> and checking the result. This example shows how to check for OpenGL ES 3.0 version:</p> 
 <pre>
private static double glVersion = 3.0;

private static class ContextFactory implements GLSurfaceView.EGLContextFactory {

  private static int EGL_CONTEXT_CLIENT_VERSION = 0x3098;

  public EGLContext createContext(
          EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {

      Log.w(TAG, &quot;creating OpenGL ES &quot; + glVersion + &quot; context&quot;);
      int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, (int) glVersion,
              EGL10.EGL_NONE };
      // attempt to create a OpenGL ES 3.0 context
      EGLContext context = egl.eglCreateContext(
              display, eglConfig, EGL10.EGL_NO_CONTEXT, attrib_list);
      return context; // returns null if 3.0 is not supported;
  }
}
</pre> 
 <p>If the <code>createContext()</code> method show above returns null, your code should create a OpenGL ES 2.0 context instead and fall back to using only that API.</p> 
 <p>The following code example demonstrates how to check the OpenGL ES version by creating a minimum supported context first, and then checking the version string:</p> 
 <pre>
// Create a minimum supported OpenGL ES context, then check:
String version = javax.microedition.khronos.opengles.GL10.glGetString(
        GL10.GL_VERSION);
Log.w(TAG, &quot;Version: &quot; + version );
// The version format is displayed as: &quot;OpenGL ES &lt;major&gt;.&lt;minor&gt;&quot;
// followed by optional content provided by the implementation.
</pre> 
 <p>With this approach, if you discover that the device supports a higher-level API version, you must destroy the minimum OpenGL ES context and create a new context with the higher available API version.</p> 
 ","EGLContext","android.opengl.EGLContext","class",0
,"Property Animation","How Property Animation Works","<h2 id="how">How Property Animation Works</h2> 
 <p>First, let's go over how an animation works with a simple example. Figure 1 depicts a hypothetical object that is animated with its <code>x</code> property, which represents its horizontal location on a screen. The duration of the animation is set to 40 ms and the distance to travel is 40 pixels. Every 10 ms, which is the default frame refresh rate, the object moves horizontally by 10 pixels. At the end of 40ms, the animation stops, and the object ends at horizontal position 40. This is an example of an animation with linear interpolation, meaning the object moves at a constant speed.</p>
 <img src="../../../images/animation/animation-linear.png" /> 
 <p class="img-caption"><strong>Figure 1.</strong> Example of a linear animation</p> 
 <p>You can also specify animations to have a non-linear interpolation. Figure 2 illustrates a hypothetical object that accelerates at the beginning of the animation, and decelerates at the end of the animation. The object still moves 40 pixels in 40 ms, but non-linearly. In the beginning, this animation accelerates up to the halfway point then decelerates from the halfway point until the end of the animation. As Figure 2 shows, the distance traveled at the beginning and end of the animation is less than in the middle.</p>
 <img src="../../../images/animation/animation-nonlinear.png" /> 
 <p class="img-caption"><strong>Figure 2.</strong> Example of a non-linear animation</p> 
 <p>Let's take a detailed look at how the important components of the property animation system would calculate animations like the ones illustrated above. Figure 3 depicts how the main classes work with one another.</p>
 <img src="../../../images/animation/valueanimator.png" /> 
 <p class="img-caption"><strong>Figure 3.</strong> How animations are calculated</p> 
 <p>The <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> object keeps track of your animation's timing, such as how long the animation has been running, and the current value of the property that it is animating.</p> 
 <p>The <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> encapsulates a <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code>, which defines animation interpolation, and a <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code>, which defines how to calculate values for the property being animated. For example, in Figure 2, the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> used would be <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> and the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> would be <code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code>.</p> 
 <p>To start an animation, create a <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and give it the starting and ending values for the property that you want to animate, along with the duration of the animation. When you call <code><a href="../../../reference/android/animation/ValueAnimator.html#start()">start()</a></code> the animation begins. During the whole animation, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calculates an <em>elapsed fraction</em> between 0 and 1, based on the duration of the animation and how much time has elapsed. The elapsed fraction represents the percentage of time that the animation has completed, 0 meaning 0% and 1 meaning 100%. For example, in Figure 1, the elapsed fraction at t = 10 ms would be .25 because the total duration is t = 40 ms.</p> 
 <p>When the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> is done calculating an elapsed fraction, it calls the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> that is currently set, to calculate an <em>interpolated fraction</em>. An interpolated fraction maps the elapsed fraction to a new fraction that takes into account the time interpolation that is set. For example, in Figure 2, because the animation slowly accelerates, the interpolated fraction, about .15, is less than the elapsed fraction, .25, at t = 10 ms. In Figure 1, the interpolated fraction is always the same as the elapsed fraction.</p> 
 <p>When the interpolated fraction is calculated, <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calls the appropriate <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code>, to calculate the value of the property that you are animating, based on the interpolated fraction, the starting value, and the ending value of the animation. For example, in Figure 2, the interpolated fraction was .15 at t = 10 ms, so the value for the property at that time would be .15 X (40 - 0), or 6.</p> 
 <!-- <p>When the final value is calculated, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calls the
  <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> method. Implement this callback to obtain the property value by
  calling <code><a href="../../../reference/android/animation/ValueAnimator.html#getAnimatedValue()">getAnimatedValue()</a></code> and set the
  value for the property in the object that you are animating. Setting the property doesn't redraw
  the object on the screen, so you need to call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> to refresh the View that the object
  resides in. If the object is actually a View object, then the system calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> when the property is changed.
  The system redraws the window and the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>
  repeats the process.</p>--> 
 <p>The <code>com.example.android.apis.animation</code> package in the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/index.html">API Demos</a> sample project provides many examples on how to use the property animation system.</p> 
 ","TypeEvaluator","android.animation.TypeEvaluator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","TypeEvaluator","android.animation.TypeEvaluator","class",0
,"Property Animation","Using a TypeEvaluator","<h2 id="type-evaluator">Using a TypeEvaluator</h2> 
 <p>If you want to animate a type that is unknown to the Android system, you can create your own evaluator by implementing the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface. The types that are known by the Android system are <code>int</code>, <code>float</code>, or a color, which are supported by the <code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code>, <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code>, and <code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code> type evaluators.</p> 
 <p>There is only one method to implement in the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface, the <code><a href="../../../reference/android/animation/TypeEvaluator.html#evaluate(float, T, T)">evaluate()</a></code> method. This allows the animator that you are using to return an appropriate value for your animated property at the current point of the animation. The <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code> class demonstrates how to do this:</p> 
 <pre>
public class FloatEvaluator implements TypeEvaluator {

    public Object evaluate(float fraction, Object startValue, Object endValue) {
        float startFloat = ((Number) startValue).floatValue();
        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);
    }
}
</pre> 
 <p class="note"><strong>Note:</strong> When <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> (or <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>) runs, it calculates a current elapsed fraction of the animation (a value between 0 and 1) and then calculates an interpolated version of that depending on what interpolator that you are using. The interpolated fraction is what your <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> receives through the <code>fraction</code> parameter, so you do not have to take into account the interpolator when calculating animated values.</p> 
 ","TypeEvaluator","android.animation.TypeEvaluator","class",1
,"Property Animation","How Property Animation Works","<h2 id="how">How Property Animation Works</h2> 
 <p>First, let's go over how an animation works with a simple example. Figure 1 depicts a hypothetical object that is animated with its <code>x</code> property, which represents its horizontal location on a screen. The duration of the animation is set to 40 ms and the distance to travel is 40 pixels. Every 10 ms, which is the default frame refresh rate, the object moves horizontally by 10 pixels. At the end of 40ms, the animation stops, and the object ends at horizontal position 40. This is an example of an animation with linear interpolation, meaning the object moves at a constant speed.</p>
 <img src="../../../images/animation/animation-linear.png" /> 
 <p class="img-caption"><strong>Figure 1.</strong> Example of a linear animation</p> 
 <p>You can also specify animations to have a non-linear interpolation. Figure 2 illustrates a hypothetical object that accelerates at the beginning of the animation, and decelerates at the end of the animation. The object still moves 40 pixels in 40 ms, but non-linearly. In the beginning, this animation accelerates up to the halfway point then decelerates from the halfway point until the end of the animation. As Figure 2 shows, the distance traveled at the beginning and end of the animation is less than in the middle.</p>
 <img src="../../../images/animation/animation-nonlinear.png" /> 
 <p class="img-caption"><strong>Figure 2.</strong> Example of a non-linear animation</p> 
 <p>Let's take a detailed look at how the important components of the property animation system would calculate animations like the ones illustrated above. Figure 3 depicts how the main classes work with one another.</p>
 <img src="../../../images/animation/valueanimator.png" /> 
 <p class="img-caption"><strong>Figure 3.</strong> How animations are calculated</p> 
 <p>The <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> object keeps track of your animation's timing, such as how long the animation has been running, and the current value of the property that it is animating.</p> 
 <p>The <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> encapsulates a <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code>, which defines animation interpolation, and a <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code>, which defines how to calculate values for the property being animated. For example, in Figure 2, the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> used would be <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> and the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> would be <code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code>.</p> 
 <p>To start an animation, create a <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and give it the starting and ending values for the property that you want to animate, along with the duration of the animation. When you call <code><a href="../../../reference/android/animation/ValueAnimator.html#start()">start()</a></code> the animation begins. During the whole animation, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calculates an <em>elapsed fraction</em> between 0 and 1, based on the duration of the animation and how much time has elapsed. The elapsed fraction represents the percentage of time that the animation has completed, 0 meaning 0% and 1 meaning 100%. For example, in Figure 1, the elapsed fraction at t = 10 ms would be .25 because the total duration is t = 40 ms.</p> 
 <p>When the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> is done calculating an elapsed fraction, it calls the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> that is currently set, to calculate an <em>interpolated fraction</em>. An interpolated fraction maps the elapsed fraction to a new fraction that takes into account the time interpolation that is set. For example, in Figure 2, because the animation slowly accelerates, the interpolated fraction, about .15, is less than the elapsed fraction, .25, at t = 10 ms. In Figure 1, the interpolated fraction is always the same as the elapsed fraction.</p> 
 <p>When the interpolated fraction is calculated, <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calls the appropriate <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code>, to calculate the value of the property that you are animating, based on the interpolated fraction, the starting value, and the ending value of the animation. For example, in Figure 2, the interpolated fraction was .15 at t = 10 ms, so the value for the property at that time would be .15 X (40 - 0), or 6.</p> 
 <!-- <p>When the final value is calculated, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calls the
  <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> method. Implement this callback to obtain the property value by
  calling <code><a href="../../../reference/android/animation/ValueAnimator.html#getAnimatedValue()">getAnimatedValue()</a></code> and set the
  value for the property in the object that you are animating. Setting the property doesn't redraw
  the object on the screen, so you need to call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> to refresh the View that the object
  resides in. If the object is actually a View object, then the system calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> when the property is changed.
  The system redraws the window and the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>
  repeats the process.</p>--> 
 <p>The <code>com.example.android.apis.animation</code> package in the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/index.html">API Demos</a> sample project provides many examples on how to use the property animation system.</p> 
 ","AccelerateDecelerateInterpolator","android.view.animation.AccelerateDecelerateInterpolator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","AccelerateDecelerateInterpolator","android.view.animation.AccelerateDecelerateInterpolator","class",0
,"Property Animation","Using Interpolators","<h2 id="interpolators">Using Interpolators</h2> 
 <p>An interpolator define how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, using acceleration or deceleration at the beginning or end of the animation.</p> 
 <p>Interpolators in the animation system receive a fraction from Animators that represent the elapsed time of the animation. Interpolators modify this fraction to coincide with the type of animation that it aims to provide. The Android system provides a set of common interpolators in the <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation package</a></code>. If none of these suit your needs, you can implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own.</p> 
 <p>As an example, how the default interpolator <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> and the <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> calculate interpolated fractions are compared below. The <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> has no effect on the elapsed fraction. The <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> accelerates into the animation and decelerates out of it. The following methods define the logic for these interpolators:</p> 
 <p><strong>AccelerateDecelerateInterpolator</strong></p> 
 <pre>
public float getInterpolation(float input) {
    return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;
}
</pre> 
 <p><strong>LinearInterpolator</strong></p> 
 <pre>
public float getInterpolation(float input) {
    return input;
}
</pre> 
 <p>The following table represents the approximate values that are calculated by these interpolators for an animation that lasts 1000ms:</p> 
 <table> 
  <tbody>
   <tr> 
    <th>ms elapsed</th> 
    <th>Elapsed fraction/Interpolated fraction (Linear)</th> 
    <th>Interpolated fraction (Accelerate/Decelerate)</th> 
   </tr> 
   <tr> 
    <td>0</td> 
    <td>0</td> 
    <td>0</td> 
   </tr> 
   <tr> 
    <td>200</td> 
    <td>.2</td> 
    <td>.1</td> 
   </tr> 
   <tr> 
    <td>400</td> 
    <td>.4</td> 
    <td>.345</td> 
   </tr> 
   <tr> 
    <td>600</td> 
    <td>.6</td> 
    <td>.8</td> 
   </tr> 
   <tr> 
    <td>800</td> 
    <td>.8</td> 
    <td>.9</td> 
   </tr> 
   <tr> 
    <td>1000</td> 
    <td>1</td> 
    <td>1</td> 
   </tr> 
  </tbody>
 </table> 
 <p>As the table shows, the <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> changes the values at the same speed, .2 for every 200ms that passes. The <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> changes the values faster than <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> between 200ms and 600ms and slower between 600ms and 1000ms.</p> 
 ","AccelerateDecelerateInterpolator","android.view.animation.AccelerateDecelerateInterpolator","class",1
,"Property Animation","How Property Animation Works","<h2 id="how">How Property Animation Works</h2> 
 <p>First, let's go over how an animation works with a simple example. Figure 1 depicts a hypothetical object that is animated with its <code>x</code> property, which represents its horizontal location on a screen. The duration of the animation is set to 40 ms and the distance to travel is 40 pixels. Every 10 ms, which is the default frame refresh rate, the object moves horizontally by 10 pixels. At the end of 40ms, the animation stops, and the object ends at horizontal position 40. This is an example of an animation with linear interpolation, meaning the object moves at a constant speed.</p>
 <img src="../../../images/animation/animation-linear.png" /> 
 <p class="img-caption"><strong>Figure 1.</strong> Example of a linear animation</p> 
 <p>You can also specify animations to have a non-linear interpolation. Figure 2 illustrates a hypothetical object that accelerates at the beginning of the animation, and decelerates at the end of the animation. The object still moves 40 pixels in 40 ms, but non-linearly. In the beginning, this animation accelerates up to the halfway point then decelerates from the halfway point until the end of the animation. As Figure 2 shows, the distance traveled at the beginning and end of the animation is less than in the middle.</p>
 <img src="../../../images/animation/animation-nonlinear.png" /> 
 <p class="img-caption"><strong>Figure 2.</strong> Example of a non-linear animation</p> 
 <p>Let's take a detailed look at how the important components of the property animation system would calculate animations like the ones illustrated above. Figure 3 depicts how the main classes work with one another.</p>
 <img src="../../../images/animation/valueanimator.png" /> 
 <p class="img-caption"><strong>Figure 3.</strong> How animations are calculated</p> 
 <p>The <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> object keeps track of your animation's timing, such as how long the animation has been running, and the current value of the property that it is animating.</p> 
 <p>The <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> encapsulates a <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code>, which defines animation interpolation, and a <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code>, which defines how to calculate values for the property being animated. For example, in Figure 2, the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> used would be <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> and the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> would be <code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code>.</p> 
 <p>To start an animation, create a <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and give it the starting and ending values for the property that you want to animate, along with the duration of the animation. When you call <code><a href="../../../reference/android/animation/ValueAnimator.html#start()">start()</a></code> the animation begins. During the whole animation, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calculates an <em>elapsed fraction</em> between 0 and 1, based on the duration of the animation and how much time has elapsed. The elapsed fraction represents the percentage of time that the animation has completed, 0 meaning 0% and 1 meaning 100%. For example, in Figure 1, the elapsed fraction at t = 10 ms would be .25 because the total duration is t = 40 ms.</p> 
 <p>When the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> is done calculating an elapsed fraction, it calls the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> that is currently set, to calculate an <em>interpolated fraction</em>. An interpolated fraction maps the elapsed fraction to a new fraction that takes into account the time interpolation that is set. For example, in Figure 2, because the animation slowly accelerates, the interpolated fraction, about .15, is less than the elapsed fraction, .25, at t = 10 ms. In Figure 1, the interpolated fraction is always the same as the elapsed fraction.</p> 
 <p>When the interpolated fraction is calculated, <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calls the appropriate <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code>, to calculate the value of the property that you are animating, based on the interpolated fraction, the starting value, and the ending value of the animation. For example, in Figure 2, the interpolated fraction was .15 at t = 10 ms, so the value for the property at that time would be .15 X (40 - 0), or 6.</p> 
 <!-- <p>When the final value is calculated, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calls the
  <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> method. Implement this callback to obtain the property value by
  calling <code><a href="../../../reference/android/animation/ValueAnimator.html#getAnimatedValue()">getAnimatedValue()</a></code> and set the
  value for the property in the object that you are animating. Setting the property doesn't redraw
  the object on the screen, so you need to call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> to refresh the View that the object
  resides in. If the object is actually a View object, then the system calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> when the property is changed.
  The system redraws the window and the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>
  repeats the process.</p>--> 
 <p>The <code>com.example.android.apis.animation</code> package in the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/index.html">API Demos</a> sample project provides many examples on how to use the property animation system.</p> 
 ","IntEvaluator","android.animation.IntEvaluator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","IntEvaluator","android.animation.IntEvaluator","class",0
,"Property Animation","Using a TypeEvaluator","<h2 id="type-evaluator">Using a TypeEvaluator</h2> 
 <p>If you want to animate a type that is unknown to the Android system, you can create your own evaluator by implementing the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface. The types that are known by the Android system are <code>int</code>, <code>float</code>, or a color, which are supported by the <code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code>, <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code>, and <code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code> type evaluators.</p> 
 <p>There is only one method to implement in the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface, the <code><a href="../../../reference/android/animation/TypeEvaluator.html#evaluate(float, T, T)">evaluate()</a></code> method. This allows the animator that you are using to return an appropriate value for your animated property at the current point of the animation. The <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code> class demonstrates how to do this:</p> 
 <pre>
public class FloatEvaluator implements TypeEvaluator {

    public Object evaluate(float fraction, Object startValue, Object endValue) {
        float startFloat = ((Number) startValue).floatValue();
        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);
    }
}
</pre> 
 <p class="note"><strong>Note:</strong> When <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> (or <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>) runs, it calculates a current elapsed fraction of the animation (a value between 0 and 1) and then calculates an interpolated version of that depending on what interpolator that you are using. The interpolated fraction is what your <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> receives through the <code>fraction</code> parameter, so you do not have to take into account the interpolator when calculating animated values.</p> 
 ","IntEvaluator","android.animation.IntEvaluator","class",0
,"Property Animation","How Property Animation Works","<h2 id="how">How Property Animation Works</h2> 
 <p>First, let's go over how an animation works with a simple example. Figure 1 depicts a hypothetical object that is animated with its <code>x</code> property, which represents its horizontal location on a screen. The duration of the animation is set to 40 ms and the distance to travel is 40 pixels. Every 10 ms, which is the default frame refresh rate, the object moves horizontally by 10 pixels. At the end of 40ms, the animation stops, and the object ends at horizontal position 40. This is an example of an animation with linear interpolation, meaning the object moves at a constant speed.</p>
 <img src="../../../images/animation/animation-linear.png" /> 
 <p class="img-caption"><strong>Figure 1.</strong> Example of a linear animation</p> 
 <p>You can also specify animations to have a non-linear interpolation. Figure 2 illustrates a hypothetical object that accelerates at the beginning of the animation, and decelerates at the end of the animation. The object still moves 40 pixels in 40 ms, but non-linearly. In the beginning, this animation accelerates up to the halfway point then decelerates from the halfway point until the end of the animation. As Figure 2 shows, the distance traveled at the beginning and end of the animation is less than in the middle.</p>
 <img src="../../../images/animation/animation-nonlinear.png" /> 
 <p class="img-caption"><strong>Figure 2.</strong> Example of a non-linear animation</p> 
 <p>Let's take a detailed look at how the important components of the property animation system would calculate animations like the ones illustrated above. Figure 3 depicts how the main classes work with one another.</p>
 <img src="../../../images/animation/valueanimator.png" /> 
 <p class="img-caption"><strong>Figure 3.</strong> How animations are calculated</p> 
 <p>The <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> object keeps track of your animation's timing, such as how long the animation has been running, and the current value of the property that it is animating.</p> 
 <p>The <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> encapsulates a <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code>, which defines animation interpolation, and a <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code>, which defines how to calculate values for the property being animated. For example, in Figure 2, the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> used would be <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> and the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> would be <code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code>.</p> 
 <p>To start an animation, create a <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and give it the starting and ending values for the property that you want to animate, along with the duration of the animation. When you call <code><a href="../../../reference/android/animation/ValueAnimator.html#start()">start()</a></code> the animation begins. During the whole animation, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calculates an <em>elapsed fraction</em> between 0 and 1, based on the duration of the animation and how much time has elapsed. The elapsed fraction represents the percentage of time that the animation has completed, 0 meaning 0% and 1 meaning 100%. For example, in Figure 1, the elapsed fraction at t = 10 ms would be .25 because the total duration is t = 40 ms.</p> 
 <p>When the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> is done calculating an elapsed fraction, it calls the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> that is currently set, to calculate an <em>interpolated fraction</em>. An interpolated fraction maps the elapsed fraction to a new fraction that takes into account the time interpolation that is set. For example, in Figure 2, because the animation slowly accelerates, the interpolated fraction, about .15, is less than the elapsed fraction, .25, at t = 10 ms. In Figure 1, the interpolated fraction is always the same as the elapsed fraction.</p> 
 <p>When the interpolated fraction is calculated, <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calls the appropriate <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code>, to calculate the value of the property that you are animating, based on the interpolated fraction, the starting value, and the ending value of the animation. For example, in Figure 2, the interpolated fraction was .15 at t = 10 ms, so the value for the property at that time would be .15 X (40 - 0), or 6.</p> 
 <!-- <p>When the final value is calculated, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calls the
  <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> method. Implement this callback to obtain the property value by
  calling <code><a href="../../../reference/android/animation/ValueAnimator.html#getAnimatedValue()">getAnimatedValue()</a></code> and set the
  value for the property in the object that you are animating. Setting the property doesn't redraw
  the object on the screen, so you need to call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> to refresh the View that the object
  resides in. If the object is actually a View object, then the system calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> when the property is changed.
  The system redraws the window and the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>
  repeats the process.</p>--> 
 <p>The <code>com.example.android.apis.animation</code> package in the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/index.html">API Demos</a> sample project provides many examples on how to use the property animation system.</p> 
 ","TimeInterpolator","android.animation.TimeInterpolator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","TimeInterpolator","android.animation.TimeInterpolator","class",0
,"Property Animation","Using Interpolators","<h2 id="interpolators">Using Interpolators</h2> 
 <p>An interpolator define how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, using acceleration or deceleration at the beginning or end of the animation.</p> 
 <p>Interpolators in the animation system receive a fraction from Animators that represent the elapsed time of the animation. Interpolators modify this fraction to coincide with the type of animation that it aims to provide. The Android system provides a set of common interpolators in the <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation package</a></code>. If none of these suit your needs, you can implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own.</p> 
 <p>As an example, how the default interpolator <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> and the <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> calculate interpolated fractions are compared below. The <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> has no effect on the elapsed fraction. The <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> accelerates into the animation and decelerates out of it. The following methods define the logic for these interpolators:</p> 
 <p><strong>AccelerateDecelerateInterpolator</strong></p> 
 <pre>
public float getInterpolation(float input) {
    return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;
}
</pre> 
 <p><strong>LinearInterpolator</strong></p> 
 <pre>
public float getInterpolation(float input) {
    return input;
}
</pre> 
 <p>The following table represents the approximate values that are calculated by these interpolators for an animation that lasts 1000ms:</p> 
 <table> 
  <tbody>
   <tr> 
    <th>ms elapsed</th> 
    <th>Elapsed fraction/Interpolated fraction (Linear)</th> 
    <th>Interpolated fraction (Accelerate/Decelerate)</th> 
   </tr> 
   <tr> 
    <td>0</td> 
    <td>0</td> 
    <td>0</td> 
   </tr> 
   <tr> 
    <td>200</td> 
    <td>.2</td> 
    <td>.1</td> 
   </tr> 
   <tr> 
    <td>400</td> 
    <td>.4</td> 
    <td>.345</td> 
   </tr> 
   <tr> 
    <td>600</td> 
    <td>.6</td> 
    <td>.8</td> 
   </tr> 
   <tr> 
    <td>800</td> 
    <td>.8</td> 
    <td>.9</td> 
   </tr> 
   <tr> 
    <td>1000</td> 
    <td>1</td> 
    <td>1</td> 
   </tr> 
  </tbody>
 </table> 
 <p>As the table shows, the <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> changes the values at the same speed, .2 for every 200ms that passes. The <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> changes the values faster than <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> between 200ms and 600ms and slower between 600ms and 1000ms.</p> 
 ","TimeInterpolator","android.animation.TimeInterpolator","class",0
,"Property Animation","How Property Animation Works","<h2 id="how">How Property Animation Works</h2> 
 <p>First, let's go over how an animation works with a simple example. Figure 1 depicts a hypothetical object that is animated with its <code>x</code> property, which represents its horizontal location on a screen. The duration of the animation is set to 40 ms and the distance to travel is 40 pixels. Every 10 ms, which is the default frame refresh rate, the object moves horizontally by 10 pixels. At the end of 40ms, the animation stops, and the object ends at horizontal position 40. This is an example of an animation with linear interpolation, meaning the object moves at a constant speed.</p>
 <img src="../../../images/animation/animation-linear.png" /> 
 <p class="img-caption"><strong>Figure 1.</strong> Example of a linear animation</p> 
 <p>You can also specify animations to have a non-linear interpolation. Figure 2 illustrates a hypothetical object that accelerates at the beginning of the animation, and decelerates at the end of the animation. The object still moves 40 pixels in 40 ms, but non-linearly. In the beginning, this animation accelerates up to the halfway point then decelerates from the halfway point until the end of the animation. As Figure 2 shows, the distance traveled at the beginning and end of the animation is less than in the middle.</p>
 <img src="../../../images/animation/animation-nonlinear.png" /> 
 <p class="img-caption"><strong>Figure 2.</strong> Example of a non-linear animation</p> 
 <p>Let's take a detailed look at how the important components of the property animation system would calculate animations like the ones illustrated above. Figure 3 depicts how the main classes work with one another.</p>
 <img src="../../../images/animation/valueanimator.png" /> 
 <p class="img-caption"><strong>Figure 3.</strong> How animations are calculated</p> 
 <p>The <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> object keeps track of your animation's timing, such as how long the animation has been running, and the current value of the property that it is animating.</p> 
 <p>The <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> encapsulates a <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code>, which defines animation interpolation, and a <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code>, which defines how to calculate values for the property being animated. For example, in Figure 2, the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> used would be <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> and the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> would be <code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code>.</p> 
 <p>To start an animation, create a <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and give it the starting and ending values for the property that you want to animate, along with the duration of the animation. When you call <code><a href="../../../reference/android/animation/ValueAnimator.html#start()">start()</a></code> the animation begins. During the whole animation, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calculates an <em>elapsed fraction</em> between 0 and 1, based on the duration of the animation and how much time has elapsed. The elapsed fraction represents the percentage of time that the animation has completed, 0 meaning 0% and 1 meaning 100%. For example, in Figure 1, the elapsed fraction at t = 10 ms would be .25 because the total duration is t = 40 ms.</p> 
 <p>When the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> is done calculating an elapsed fraction, it calls the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> that is currently set, to calculate an <em>interpolated fraction</em>. An interpolated fraction maps the elapsed fraction to a new fraction that takes into account the time interpolation that is set. For example, in Figure 2, because the animation slowly accelerates, the interpolated fraction, about .15, is less than the elapsed fraction, .25, at t = 10 ms. In Figure 1, the interpolated fraction is always the same as the elapsed fraction.</p> 
 <p>When the interpolated fraction is calculated, <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calls the appropriate <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code>, to calculate the value of the property that you are animating, based on the interpolated fraction, the starting value, and the ending value of the animation. For example, in Figure 2, the interpolated fraction was .15 at t = 10 ms, so the value for the property at that time would be .15 X (40 - 0), or 6.</p> 
 <!-- <p>When the final value is calculated, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> calls the
  <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> method. Implement this callback to obtain the property value by
  calling <code><a href="../../../reference/android/animation/ValueAnimator.html#getAnimatedValue()">getAnimatedValue()</a></code> and set the
  value for the property in the object that you are animating. Setting the property doesn't redraw
  the object on the screen, so you need to call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> to refresh the View that the object
  resides in. If the object is actually a View object, then the system calls <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> when the property is changed.
  The system redraws the window and the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>
  repeats the process.</p>--> 
 <p>The <code>com.example.android.apis.animation</code> package in the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/index.html">API Demos</a> sample project provides many examples on how to use the property animation system.</p> 
 ","ValueAnimator","android.animation.ValueAnimator","class",1
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","ValueAnimator","android.animation.ValueAnimator","class",0
,"Property Animation","Animating with ValueAnimator","<h2 id="value-animator">Animating with ValueAnimator</h2> 
 <p>The <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> class lets you animate values of some type for the duration of an animation by specifying a set of <code>int</code>, <code>float</code>, or color values to animate through. You obtain a <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> by calling one of its factory methods: <code><a href="../../../reference/android/animation/ValueAnimator.html#ofInt(int...)">ofInt()</a></code>, <code><a href="../../../reference/android/animation/ValueAnimator.html#ofFloat(float...)">ofFloat()</a></code>, or <code><a href="../../../reference/android/animation/ValueAnimator.html#ofObject(android.animation.TypeEvaluator, java.lang.Object...)">ofObject()</a></code>. For example:</p> 
 <pre>
ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f);
animation.setDuration(1000);
animation.start();
</pre> 
 <p>In this code, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> starts calculating the values of the animation, between 0 and 1, for a duration of 1000 ms, when the <code>start()</code> method runs.</p> 
 <p>You can also specify a custom type to animate by doing the following:</p> 
 <pre>
ValueAnimator animation = ValueAnimator.ofObject(new MyTypeEvaluator(), startPropertyValue, endPropertyValue);
animation.setDuration(1000);
animation.start();
</pre> 
 <p>In this code, the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> starts calculating the values of the animation, between <code>startPropertyValue</code> and <code>endPropertyValue</code> using the logic supplied by <code>MyTypeEvaluator</code> for a duration of 1000 ms, when the <code><a href="../../../reference/android/animation/ValueAnimator.html#start()">start()</a></code> method runs.</p> 
 <p>The previous code snippets, however, has no real effect on an object, because the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not operate on objects or properties directly. The most likely thing that you want to do is modify the objects that you want to animate with these calculated values. You do this by defining listeners in the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> to appropriately handle important events during the animation's lifespan, such as frame updates. When implementing the listeners, you can obtain the calculated value for that specific frame refresh by calling <code><a href="../../../reference/android/animation/ValueAnimator.html#getAnimatedValue()">getAnimatedValue()</a></code>. For more information on listeners, see the section about <a href="#listeners">Animation Listeners</a>. </p>
 ","ValueAnimator","android.animation.ValueAnimator","class",1
,"Property Animation","Animating with ObjectAnimator","<h2 id="object-animator">Animating with ObjectAnimator</h2> 
 <p>The <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> is a subclass of the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> (discussed in the previous section) and combines the timing engine and value computation of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> with the ability to animate a named property of a target object. This makes animating any object much easier, as you no longer need to implement the <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html">ValueAnimator.AnimatorUpdateListener</a></code>, because the animated property updates automatically.</p> 
 <p>Instantiating an <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> is similar to a <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>, but you also specify the object and the name of that object's property (as a String) along with the values to animate between:</p> 
 <pre>
ObjectAnimator anim = ObjectAnimator.ofFloat(foo, &quot;alpha&quot;, 0f, 1f);
anim.setDuration(1000);
anim.start();
</pre> 
 <p>To have the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> update properties correctly, you must do the following:</p> 
 <ul> 
  <li>The object property that you are animating must have a setter function (in camel case) in the form of <code>set&lt;propertyName&gt;()</code>. Because the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> automatically updates the property during animation, it must be able to access the property with this setter method. For example, if the property name is <code>foo</code>, you need to have a <code>setFoo()</code> method. If this setter method does not exist, you have three options: 
   <ul> 
    <li>Add the setter method to the class if you have the rights to do so.</li> 
    <li>Use a wrapper class that you have rights to change and have that wrapper receive the value with a valid setter method and forward it to the original object.</li> 
    <li>Use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> instead.</li> 
   </ul> </li> 
  <li>If you specify only one value for the <code>values...</code> parameter in one of the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> factory methods, it is assumed to be the ending value of the animation. Therefore, the object property that you are animating must have a getter function that is used to obtain the starting value of the animation. The getter function must be in the form of <code>get&lt;propertyName&gt;()</code>. For example, if the property name is <code>foo</code>, you need to have a <code>getFoo()</code> method.</li> 
  <li>The getter (if needed) and setter methods of the property that you are animating must operate on the same type as the starting and ending values that you specify to <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>. For example, you must have <code>targetObject.setPropName(float)</code> and <code>targetObject.getPropName(float)</code> if you construct the following <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>: <pre>
ObjectAnimator.ofFloat(targetObject, &quot;propName&quot;, 1f)
</pre> </li> 
  <li>Depending on what property or object you are animating, you might need to call the <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> method on a View to force the screen to redraw itself with the updated animated values. You do this in the <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> callback. For example, animating the color property of a Drawable object only cause updates to the screen when that object redraws itself. All of the property setters on View, such as <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code> and <code><a href="../../../reference/android/view/View.html#setTranslationX(float)">setTranslationX()</a></code> invalidate the View properly, so you do not need to invalidate the View when calling these methods with new values. For more information on listeners, see the section about <a href="#listeners">Animation Listeners</a>. </li> 
 </ul> 
 ","ValueAnimator","android.animation.ValueAnimator","class",0
,"Property Animation","Animation Listeners","<h2 id="listeners">Animation Listeners</h2> 
 <p> You can listen for important events during an animation's duration with the listeners described below. </p> 
 <ul> 
  <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> 
   <ul> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationStart(android.animation.Animator)">onAnimationStart()</a></code> - Called when the animation starts.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code> - Called when the animation ends.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationRepeat(android.animation.Animator)">onAnimationRepeat()</a></code> - Called when the animation repeats itself.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationCancel(android.animation.Animator)">onAnimationCancel()</a></code> - Called when the animation is canceled. A cancelled animation also calls <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code>, regardless of how they were ended.</li> 
   </ul> </li> 
  <li><code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html">ValueAnimator.AnimatorUpdateListener</a></code> 
   <ul> 
    <li> <p><code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> - called on every frame of the animation. Listen to this event to use the calculated values generated by <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> during an animation. To use the value, query the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> object passed into the event to get the current animated value with the <code><a href="../../../reference/android/animation/ValueAnimator.html#getAnimatedValue()">getAnimatedValue()</a></code> method. Implementing this listener is required if you use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>. </p> <p> Depending on what property or object you are animating, you might need to call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> on a View to force that area of the screen to redraw itself with the new animated values. For example, animating the color property of a Drawable object only cause updates to the screen when that object redraws itself. All of the property setters on View, such as <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code> and <code><a href="../../../reference/android/view/View.html#setTranslationX(float)">setTranslationX()</a></code> invalidate the View properly, so you do not need to invalidate the View when calling these methods with new values. </p> </li> 
   </ul> </li> 
 </ul> 
 <p>You can extend the <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> class instead of implementing the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> interface, if you do not want to implement all of the methods of the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> interface. The <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> class provides empty implementations of the methods that you can choose to override.</p> 
 <p>For example, the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/BouncingBalls.html">Bouncing Balls</a> sample in the API demos creates an <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> for just the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code> callback:</p> 
 <pre>
ValueAnimatorAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, &quot;alpha&quot;, 1f, 0f);
fadeAnim.setDuration(250);
fadeAnim.addListener(new AnimatorListenerAdapter() {
public void onAnimationEnd(Animator animation) {
    balls.remove(((ObjectAnimator)animation).getTarget());
}
</pre> 
 ","ValueAnimator","android.animation.ValueAnimator","class",1
,"Property Animation","Using a TypeEvaluator","<h2 id="type-evaluator">Using a TypeEvaluator</h2> 
 <p>If you want to animate a type that is unknown to the Android system, you can create your own evaluator by implementing the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface. The types that are known by the Android system are <code>int</code>, <code>float</code>, or a color, which are supported by the <code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code>, <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code>, and <code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code> type evaluators.</p> 
 <p>There is only one method to implement in the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface, the <code><a href="../../../reference/android/animation/TypeEvaluator.html#evaluate(float, T, T)">evaluate()</a></code> method. This allows the animator that you are using to return an appropriate value for your animated property at the current point of the animation. The <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code> class demonstrates how to do this:</p> 
 <pre>
public class FloatEvaluator implements TypeEvaluator {

    public Object evaluate(float fraction, Object startValue, Object endValue) {
        float startFloat = ((Number) startValue).floatValue();
        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);
    }
}
</pre> 
 <p class="note"><strong>Note:</strong> When <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> (or <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>) runs, it calculates a current elapsed fraction of the animation (a value between 0 and 1) and then calculates an interpolated version of that depending on what interpolator that you are using. The interpolated fraction is what your <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> receives through the <code>fraction</code> parameter, so you do not have to take into account the interpolator when calculating animated values.</p> 
 ","ValueAnimator","android.animation.ValueAnimator","class",0
,"Property Animation","Declaring Animations in XML","<h2 id="declaring-xml">Declaring Animations in XML</h2> 
 <p>The property animation system lets you declare property animations with XML instead of doing it programmatically. By defining your animations in XML, you can easily reuse your animations in multiple activities and more easily edit the animation sequence.</p> 
 <p>To distinguish animation files that use the new property animation APIs from those that use the legacy <a href="../../../guide/topics/graphics/view-animation.html">view animation</a> framework, starting with Android 3.1, you should save the XML files for property animations in the <code>res/animator/</code> directory (instead of <code>res/anim/</code>). Using the <code>animator</code> directory name is optional, but necessary if you want to use the layout editor tools in the Eclipse ADT plugin (ADT 11.0.0+), because ADT only searches the <code>res/animator/</code> directory for property animation resources.</p> 
 <p>The following property animation classes have XML declaration support with the following XML tags:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> - <code>&lt;animator&gt;</code></li> 
  <li><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> - <code>&lt;objectAnimator&gt;</code></li> 
  <li><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> - <code>&lt;set&gt;</code></li> 
 </ul> 
 <p>The following example plays the two sets of object animations sequentially, with the first nested set playing two object animations together:</p> 
 <pre>
&lt;set android:ordering=&quot;sequentially&quot;&gt;
    &lt;set&gt;
        &lt;objectAnimator
            android:propertyName=&quot;x&quot;
            android:duration=&quot;500&quot;
            android:valueTo=&quot;400&quot;
            android:valueType=&quot;intType&quot;/&gt;
        &lt;objectAnimator
            android:propertyName=&quot;y&quot;
            android:duration=&quot;500&quot;
            android:valueTo=&quot;300&quot;
            android:valueType=&quot;intType&quot;/&gt;
    &lt;/set&gt;
    &lt;objectAnimator
        android:propertyName=&quot;alpha&quot;
        android:duration=&quot;500&quot;
        android:valueTo=&quot;1f&quot;/&gt;
&lt;/set&gt;
</pre> 
 <p>In order to run this animation, you must inflate the XML resources in your code to an <code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> object, and then set the target objects for all of the animations before starting the animation set. Calling <code><a href="../../../reference/android/animation/AnimatorSet.html#setTarget(java.lang.Object)">setTarget()</a></code> sets a single target object for all children of the <code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> as a convenience. The following code shows how to do this:</p> 
 <pre>
AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,
    R.anim.property_animator);
set.setTarget(myObject);
set.start();
</pre> 
 <p>For information about the XML syntax for defining property animations, see <a href="../../../guide/topics/resources/animation-resource.html#Property">Animation Resources</a>. </p>
</div> 
","ValueAnimator","android.animation.ValueAnimator","class",1
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","AnticipateInterpolator","android.view.animation.AnticipateInterpolator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","BounceInterpolator","android.view.animation.BounceInterpolator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","Animator","android.animation.Animator","class",0
,"Property Animation","Choreographing Multiple Animations with AnimatorSet","<h2 id="choreography">Choreographing Multiple Animations with AnimatorSet</h2> 
 <p>In many cases, you want to play an animation that depends on when another animation starts or finishes. The Android system lets you bundle animations together into an <code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code>, so that you can specify whether to start animations simultaneously, sequentially, or after a specified delay. You can also nest <code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> objects within each other.</p> 
 <p>The following sample code taken from the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/BouncingBalls.html">Bouncing Balls</a> sample (modified for simplicity) plays the following <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> objects in the following manner:</p> 
 <ol> 
  <li>Plays <code>bounceAnim</code>.</li> 
  <li>Plays <code>squashAnim1</code>, <code>squashAnim2</code>, <code>stretchAnim1</code>, and <code>stretchAnim2</code> at the same time.</li> 
  <li>Plays <code>bounceBackAnim</code>.</li> 
  <li>Plays <code>fadeAnim</code>.</li> 
 </ol> 
 <pre>
AnimatorSet bouncer = new AnimatorSet();
bouncer.play(bounceAnim).before(squashAnim1);
bouncer.play(squashAnim1).with(squashAnim2);
bouncer.play(squashAnim1).with(stretchAnim1);
bouncer.play(squashAnim1).with(stretchAnim2);
bouncer.play(bounceBackAnim).after(stretchAnim2);
ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, &quot;alpha&quot;, 1f, 0f);
fadeAnim.setDuration(250);
AnimatorSet animatorSet = new AnimatorSet();
animatorSet.play(bouncer).before(fadeAnim);
animatorSet.start();
</pre> 
 <p>For a more complete example on how to use animator sets, see the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/BouncingBalls.html">Bouncing Balls</a> sample in APIDemos.</p> 
 ","Animator","android.animation.Animator","class",0
,"Property Animation","Animating Layout Changes to ViewGroups","<h2 id="layout">Animating Layout Changes to ViewGroups</h2> 
 <p>The property animation system provides the capability to animate changes to ViewGroup objects as well as provide an easy way to animate View objects themselves.</p> 
 <p>You can animate layout changes within a ViewGroup with the <code><a href="../../../reference/android/animation/LayoutTransition.html">LayoutTransition</a></code> class. Views inside a ViewGroup can go through an appearing and disappearing animation when you add them to or remove them from a ViewGroup or when you call a View's <code><a href="../../../reference/android/view/View.html#setVisibility(int)">setVisibility()</a></code> method with <code><a href="../../../reference/android/view/View.html#VISIBLE">VISIBLE</a></code>, android.view.View#INVISIBLE}, or <code><a href="../../../reference/android/view/View.html#GONE">GONE</a></code>. The remaining Views in the ViewGroup can also animate into their new positions when you add or remove Views. You can define the following animations in a <code><a href="../../../reference/android/animation/LayoutTransition.html">LayoutTransition</a></code> object by calling <code><a href="../../../reference/android/animation/LayoutTransition.html#setAnimator(int, android.animation.Animator)">setAnimator()</a></code> and passing in an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> object with one of the following <code><a href="../../../reference/android/animation/LayoutTransition.html">LayoutTransition</a></code> constants:</p> 
 <ul> 
  <li><code>APPEARING</code> - A flag indicating the animation that runs on items that are appearing in the container.</li> 
  <li><code>CHANGE_APPEARING</code> - A flag indicating the animation that runs on items that are changing due to a new item appearing in the container.</li> 
  <li><code>DISAPPEARING</code> - A flag indicating the animation that runs on items that are disappearing from the container.</li> 
  <li><code>CHANGE_DISAPPEARING</code> - A flag indicating the animation that runs on items that are changing due to an item disappearing from the container.</li> 
 </ul> 
 <p>You can define your own custom animations for these four types of events to customize the look of your layout transitions or just tell the animation system to use the default animations.</p> 
 <p>The <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/LayoutAnimations.html"> LayoutAnimations</a> sample in API Demos shows you how to define animations for layout transitions and then set the animations on the View objects that you want to animate.</p> 
 <p>The <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/LayoutAnimationsByDefault.html"> LayoutAnimationsByDefault</a> and its corresponding <a href="../../../resources/samples/ApiDemos/res/layout/layout_animations_by_default.html">layout_animations_by_default.xml</a> layout resource file show you how to enable the default layout transitions for ViewGroups in XML. The only thing that you need to do is to set the <code>android:animateLayoutchanges</code> attribute to <code>true</code> for the ViewGroup. For example:</p> 
 <pre>
&lt;LinearLayout
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;match_parent&quot;
    android:id=&quot;@+id/verticalContainer&quot;
    android:animateLayoutChanges=&quot;true&quot; /&gt;
</pre> 
 <p>Setting this attribute to true automatically animates Views that are added or removed from the ViewGroup as well as the remaining Views in the ViewGroup.</p> 
 ","Animator","android.animation.Animator","class",0
,"Animating Views","Animating with ViewPropertyAnimator","<h3 id="view-prop-animator">Animating with ViewPropertyAnimator</h3> 
 <p>The <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> provides a simple way to animate several properties of a <code><a href="../../../reference/android/view/View.html">View</a></code> in parallel, using a single underlying <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> object. It behaves much like an <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, because it modifies the actual values of the view's properties, but is more efficient when animating many properties at once. In addition, the code for using the <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> is much more concise and easier to read. The following code snippets show the differences in using multiple <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> objects, a single <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, and the <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> when simultaneously animating the <code>x</code> and <code>y</code> property of a view.</p> 
 <p><strong>Multiple ObjectAnimator objects</strong></p> 
 <pre>
ObjectAnimator animX = ObjectAnimator.ofFloat(myView, &quot;x&quot;, 50f);
ObjectAnimator animY = ObjectAnimator.ofFloat(myView, &quot;y&quot;, 100f);
AnimatorSet animSetXY = new AnimatorSet();
animSetXY.playTogether(animX, animY);
animSetXY.start();
</pre> 
 <p><strong>One ObjectAnimator</strong></p> 
 <pre>
PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(&quot;x&quot;, 50f);
PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(&quot;y&quot;, 100f);
ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();
</pre> 
 <p><strong>ViewPropertyAnimator</strong></p> 
 <pre>
myView.animate().x(50f).y(100f);
</pre> 
 <p> For more detailed information about <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code>, see the corresponding Android Developers <a href="http://android-developers.blogspot.com/2011/05/introducing-viewpropertyanimator.html">blog post</a>.</p> 
 ","Animator","android.animation.Animator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","CycleInterpolator","android.view.animation.CycleInterpolator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","package-summary","android.view.animation.package-summary","class",1
,"Property Animation","Using Interpolators","<h2 id="interpolators">Using Interpolators</h2> 
 <p>An interpolator define how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, using acceleration or deceleration at the beginning or end of the animation.</p> 
 <p>Interpolators in the animation system receive a fraction from Animators that represent the elapsed time of the animation. Interpolators modify this fraction to coincide with the type of animation that it aims to provide. The Android system provides a set of common interpolators in the <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation package</a></code>. If none of these suit your needs, you can implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own.</p> 
 <p>As an example, how the default interpolator <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> and the <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> calculate interpolated fractions are compared below. The <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> has no effect on the elapsed fraction. The <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> accelerates into the animation and decelerates out of it. The following methods define the logic for these interpolators:</p> 
 <p><strong>AccelerateDecelerateInterpolator</strong></p> 
 <pre>
public float getInterpolation(float input) {
    return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;
}
</pre> 
 <p><strong>LinearInterpolator</strong></p> 
 <pre>
public float getInterpolation(float input) {
    return input;
}
</pre> 
 <p>The following table represents the approximate values that are calculated by these interpolators for an animation that lasts 1000ms:</p> 
 <table> 
  <tbody>
   <tr> 
    <th>ms elapsed</th> 
    <th>Elapsed fraction/Interpolated fraction (Linear)</th> 
    <th>Interpolated fraction (Accelerate/Decelerate)</th> 
   </tr> 
   <tr> 
    <td>0</td> 
    <td>0</td> 
    <td>0</td> 
   </tr> 
   <tr> 
    <td>200</td> 
    <td>.2</td> 
    <td>.1</td> 
   </tr> 
   <tr> 
    <td>400</td> 
    <td>.4</td> 
    <td>.345</td> 
   </tr> 
   <tr> 
    <td>600</td> 
    <td>.6</td> 
    <td>.8</td> 
   </tr> 
   <tr> 
    <td>800</td> 
    <td>.8</td> 
    <td>.9</td> 
   </tr> 
   <tr> 
    <td>1000</td> 
    <td>1</td> 
    <td>1</td> 
   </tr> 
  </tbody>
 </table> 
 <p>As the table shows, the <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> changes the values at the same speed, .2 for every 200ms that passes. The <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> changes the values faster than <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> between 200ms and 600ms and slower between 600ms and 1000ms.</p> 
 ","package-summary","android.view.animation.package-summary","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","FloatEvaluator","android.animation.FloatEvaluator","class",0
,"Property Animation","Using a TypeEvaluator","<h2 id="type-evaluator">Using a TypeEvaluator</h2> 
 <p>If you want to animate a type that is unknown to the Android system, you can create your own evaluator by implementing the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface. The types that are known by the Android system are <code>int</code>, <code>float</code>, or a color, which are supported by the <code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code>, <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code>, and <code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code> type evaluators.</p> 
 <p>There is only one method to implement in the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface, the <code><a href="../../../reference/android/animation/TypeEvaluator.html#evaluate(float, T, T)">evaluate()</a></code> method. This allows the animator that you are using to return an appropriate value for your animated property at the current point of the animation. The <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code> class demonstrates how to do this:</p> 
 <pre>
public class FloatEvaluator implements TypeEvaluator {

    public Object evaluate(float fraction, Object startValue, Object endValue) {
        float startFloat = ((Number) startValue).floatValue();
        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);
    }
}
</pre> 
 <p class="note"><strong>Note:</strong> When <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> (or <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>) runs, it calculates a current elapsed fraction of the animation (a value between 0 and 1) and then calculates an interpolated version of that depending on what interpolator that you are using. The interpolated fraction is what your <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> receives through the <code>fraction</code> parameter, so you do not have to take into account the interpolator when calculating animated values.</p> 
 ","FloatEvaluator","android.animation.FloatEvaluator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","AnticipateOvershootInterpolator","android.view.animation.AnticipateOvershootInterpolator","class",1
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","OvershootInterpolator","android.view.animation.OvershootInterpolator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","LinearInterpolator","android.view.animation.LinearInterpolator","class",0
,"Property Animation","Using Interpolators","<h2 id="interpolators">Using Interpolators</h2> 
 <p>An interpolator define how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, using acceleration or deceleration at the beginning or end of the animation.</p> 
 <p>Interpolators in the animation system receive a fraction from Animators that represent the elapsed time of the animation. Interpolators modify this fraction to coincide with the type of animation that it aims to provide. The Android system provides a set of common interpolators in the <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation package</a></code>. If none of these suit your needs, you can implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own.</p> 
 <p>As an example, how the default interpolator <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> and the <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> calculate interpolated fractions are compared below. The <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> has no effect on the elapsed fraction. The <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> accelerates into the animation and decelerates out of it. The following methods define the logic for these interpolators:</p> 
 <p><strong>AccelerateDecelerateInterpolator</strong></p> 
 <pre>
public float getInterpolation(float input) {
    return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;
}
</pre> 
 <p><strong>LinearInterpolator</strong></p> 
 <pre>
public float getInterpolation(float input) {
    return input;
}
</pre> 
 <p>The following table represents the approximate values that are calculated by these interpolators for an animation that lasts 1000ms:</p> 
 <table> 
  <tbody>
   <tr> 
    <th>ms elapsed</th> 
    <th>Elapsed fraction/Interpolated fraction (Linear)</th> 
    <th>Interpolated fraction (Accelerate/Decelerate)</th> 
   </tr> 
   <tr> 
    <td>0</td> 
    <td>0</td> 
    <td>0</td> 
   </tr> 
   <tr> 
    <td>200</td> 
    <td>.2</td> 
    <td>.1</td> 
   </tr> 
   <tr> 
    <td>400</td> 
    <td>.4</td> 
    <td>.345</td> 
   </tr> 
   <tr> 
    <td>600</td> 
    <td>.6</td> 
    <td>.8</td> 
   </tr> 
   <tr> 
    <td>800</td> 
    <td>.8</td> 
    <td>.9</td> 
   </tr> 
   <tr> 
    <td>1000</td> 
    <td>1</td> 
    <td>1</td> 
   </tr> 
  </tbody>
 </table> 
 <p>As the table shows, the <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> changes the values at the same speed, .2 for every 200ms that passes. The <code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code> changes the values faster than <code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code> between 200ms and 600ms and slower between 600ms and 1000ms.</p> 
 ","LinearInterpolator","android.view.animation.LinearInterpolator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","AnimatorSet","android.animation.AnimatorSet","class",1
,"Property Animation","Choreographing Multiple Animations with AnimatorSet","<h2 id="choreography">Choreographing Multiple Animations with AnimatorSet</h2> 
 <p>In many cases, you want to play an animation that depends on when another animation starts or finishes. The Android system lets you bundle animations together into an <code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code>, so that you can specify whether to start animations simultaneously, sequentially, or after a specified delay. You can also nest <code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> objects within each other.</p> 
 <p>The following sample code taken from the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/BouncingBalls.html">Bouncing Balls</a> sample (modified for simplicity) plays the following <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> objects in the following manner:</p> 
 <ol> 
  <li>Plays <code>bounceAnim</code>.</li> 
  <li>Plays <code>squashAnim1</code>, <code>squashAnim2</code>, <code>stretchAnim1</code>, and <code>stretchAnim2</code> at the same time.</li> 
  <li>Plays <code>bounceBackAnim</code>.</li> 
  <li>Plays <code>fadeAnim</code>.</li> 
 </ol> 
 <pre>
AnimatorSet bouncer = new AnimatorSet();
bouncer.play(bounceAnim).before(squashAnim1);
bouncer.play(squashAnim1).with(squashAnim2);
bouncer.play(squashAnim1).with(stretchAnim1);
bouncer.play(squashAnim1).with(stretchAnim2);
bouncer.play(bounceBackAnim).after(stretchAnim2);
ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, &quot;alpha&quot;, 1f, 0f);
fadeAnim.setDuration(250);
AnimatorSet animatorSet = new AnimatorSet();
animatorSet.play(bouncer).before(fadeAnim);
animatorSet.start();
</pre> 
 <p>For a more complete example on how to use animator sets, see the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/BouncingBalls.html">Bouncing Balls</a> sample in APIDemos.</p> 
 ","AnimatorSet","android.animation.AnimatorSet","class",0
,"Property Animation","Declaring Animations in XML","<h2 id="declaring-xml">Declaring Animations in XML</h2> 
 <p>The property animation system lets you declare property animations with XML instead of doing it programmatically. By defining your animations in XML, you can easily reuse your animations in multiple activities and more easily edit the animation sequence.</p> 
 <p>To distinguish animation files that use the new property animation APIs from those that use the legacy <a href="../../../guide/topics/graphics/view-animation.html">view animation</a> framework, starting with Android 3.1, you should save the XML files for property animations in the <code>res/animator/</code> directory (instead of <code>res/anim/</code>). Using the <code>animator</code> directory name is optional, but necessary if you want to use the layout editor tools in the Eclipse ADT plugin (ADT 11.0.0+), because ADT only searches the <code>res/animator/</code> directory for property animation resources.</p> 
 <p>The following property animation classes have XML declaration support with the following XML tags:</p> 
 <ul> 
  <li><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> - <code>&lt;animator&gt;</code></li> 
  <li><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> - <code>&lt;objectAnimator&gt;</code></li> 
  <li><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> - <code>&lt;set&gt;</code></li> 
 </ul> 
 <p>The following example plays the two sets of object animations sequentially, with the first nested set playing two object animations together:</p> 
 <pre>
&lt;set android:ordering=&quot;sequentially&quot;&gt;
    &lt;set&gt;
        &lt;objectAnimator
            android:propertyName=&quot;x&quot;
            android:duration=&quot;500&quot;
            android:valueTo=&quot;400&quot;
            android:valueType=&quot;intType&quot;/&gt;
        &lt;objectAnimator
            android:propertyName=&quot;y&quot;
            android:duration=&quot;500&quot;
            android:valueTo=&quot;300&quot;
            android:valueType=&quot;intType&quot;/&gt;
    &lt;/set&gt;
    &lt;objectAnimator
        android:propertyName=&quot;alpha&quot;
        android:duration=&quot;500&quot;
        android:valueTo=&quot;1f&quot;/&gt;
&lt;/set&gt;
</pre> 
 <p>In order to run this animation, you must inflate the XML resources in your code to an <code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> object, and then set the target objects for all of the animations before starting the animation set. Calling <code><a href="../../../reference/android/animation/AnimatorSet.html#setTarget(java.lang.Object)">setTarget()</a></code> sets a single target object for all children of the <code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code> as a convenience. The following code shows how to do this:</p> 
 <pre>
AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,
    R.anim.property_animator);
set.setTarget(myObject);
set.start();
</pre> 
 <p>For information about the XML syntax for defining property animations, see <a href="../../../guide/topics/resources/animation-resource.html#Property">Animation Resources</a>. </p>
</div> 
","AnimatorSet","android.animation.AnimatorSet","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","ArgbEvaluator","android.animation.ArgbEvaluator","class",0
,"Property Animation","Using a TypeEvaluator","<h2 id="type-evaluator">Using a TypeEvaluator</h2> 
 <p>If you want to animate a type that is unknown to the Android system, you can create your own evaluator by implementing the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface. The types that are known by the Android system are <code>int</code>, <code>float</code>, or a color, which are supported by the <code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code>, <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code>, and <code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code> type evaluators.</p> 
 <p>There is only one method to implement in the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface, the <code><a href="../../../reference/android/animation/TypeEvaluator.html#evaluate(float, T, T)">evaluate()</a></code> method. This allows the animator that you are using to return an appropriate value for your animated property at the current point of the animation. The <code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code> class demonstrates how to do this:</p> 
 <pre>
public class FloatEvaluator implements TypeEvaluator {

    public Object evaluate(float fraction, Object startValue, Object endValue) {
        float startFloat = ((Number) startValue).floatValue();
        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);
    }
}
</pre> 
 <p class="note"><strong>Note:</strong> When <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> (or <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>) runs, it calculates a current elapsed fraction of the animation (a value between 0 and 1) and then calculates an interpolated version of that depending on what interpolator that you are using. The interpolated fraction is what your <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> receives through the <code>fraction</code> parameter, so you do not have to take into account the interpolator when calculating animated values.</p> 
 ","ArgbEvaluator","android.animation.ArgbEvaluator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","DecelerateInterpolator","android.view.animation.DecelerateInterpolator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","AccelerateInterpolator","android.view.animation.AccelerateInterpolator","class",0
,"Property Animation","API Overview","<h2>API Overview</h2> 
 <p>You can find most of the property animation system's APIs in <code><a href="../../../reference/android/animation/package-summary.html">android.animation</a></code>. Because the view animation system already defines many interpolators in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>, you can use those interpolators in the property animation system as well. The following tables describe the main components of the property animation system.</p> 
 <p>The <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class provides the basic structure for creating animations. You normally do not use this class directly as it only provides minimal functionality that must be extended to fully support animating values. The following subclasses extend <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code>: </p> 
 <p class="table-caption"><strong>Table 1.</strong> Animators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code></td> 
    <td>The main timing engine for property animation that also computes the values for the property to be animated. It has all of the core functionality that calculates animation values and contains the timing details of each animation, information about whether an animation repeats, listeners that receive update events, and the ability to set custom types to evaluate. There are two pieces to animating properties: calculating the animated values and setting those values on the object and property that is being animated. <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> does not carry out the second piece, so you must listen for updates to values calculated by the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> and modify the objects that you want to animate with your own logic. See the section about <a href="#value-animator">Animating with ValueAnimator</a> for more information.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code></td> 
    <td>A subclass of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> that allows you to set a target object and object property to animate. This class updates the property accordingly when it computes a new value for the animation. You want to use <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> most of the time, because it makes the process of animating values on target objects much easier. However, you sometimes want to use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> directly because <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> has a few more restrictions, such as requiring specific acessor methods to be present on the target object.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/AnimatorSet.html">AnimatorSet</a></code></td> 
    <td>Provides a mechanism to group animations together so that they run in relation to one another. You can set animations to play together, sequentially, or after a specified delay. See the section about <a href="#choreography">Choreographing multiple animations with Animator Sets</a> for more information.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>Evaluators tell the property animation system how to calculate values for a given property. They take the timing data that is provided by an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> class, the animation's start and end value, and calculate the animated values of the property based on this data. The property animation system provides the following evaluators:</p> 
 <p class="table-caption"><strong>Table 2.</strong> Evaluators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/IntEvaluator.html">IntEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>int</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/FloatEvaluator.html">FloatEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for <code>float</code> properties.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/ArgbEvaluator.html">ArgbEvaluator</a></code></td> 
    <td>The default evaluator to calculate values for color properties that are represented as hexidecimal values.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code></td> 
    <td>An interface that allows you to create your own evaluator. If you are animating an object property that is <em>not</em> an <code>int</code>, <code>float</code>, or color, you must implement the <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> interface to specify how to compute the object property's animated values. You can also specify a custom <code><a href="../../../reference/android/animation/TypeEvaluator.html">TypeEvaluator</a></code> for <code>int</code>, <code>float</code>, and color values as well, if you want to process those types differently than the default behavior. See the section about <a href="#type-evaluator">Using a TypeEvaluator</a> for more information on how to write a custom evaluator.</td> 
   </tr> 
  </tbody>
 </table> 
 <p>A time interpolator defines how specific values in an animation are calculated as a function of time. For example, you can specify animations to happen linearly across the whole animation, meaning the animation moves evenly the entire time, or you can specify animations to use non-linear time, for example, accelerating at the beginning and decelerating at the end of the animation. Table 3 describes the interpolators that are contained in <code><a href="../../../reference/android/view/animation/package-summary.html">android.view.animation</a></code>. If none of the provided interpolators suits your needs, implement the <code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code> interface and create your own. See <a href="#interpolators">Using interpolators</a> for more information on how to write a custom interpolator.</p> 
 <p class="table-caption"><strong>Table 3.</strong> Interpolators</p> 
 <table> 
  <tbody>
   <tr> 
    <th>Class/Interface</th> 
    <th>Description</th> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateDecelerateInterpolator.html">AccelerateDecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts and ends slowly but accelerates through the middle.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AccelerateInterpolator.html">AccelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out slowly and then accelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateInterpolator.html">AnticipateInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward then flings forward.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/AnticipateOvershootInterpolator.html">AnticipateOvershootInterpolator</a></code></td> 
    <td>An interpolator whose change starts backward, flings forward and overshoots the target value, then finally goes back to the final value.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/BounceInterpolator.html">BounceInterpolator</a></code></td> 
    <td>An interpolator whose change bounces at the end.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/CycleInterpolator.html">CycleInterpolator</a></code></td> 
    <td>An interpolator whose animation repeats for a specified number of cycles.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/DecelerateInterpolator.html">DecelerateInterpolator</a></code></td> 
    <td>An interpolator whose rate of change starts out quickly and and then decelerates.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/LinearInterpolator.html">LinearInterpolator</a></code></td> 
    <td>An interpolator whose rate of change is constant.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/view/animation/OvershootInterpolator.html">OvershootInterpolator</a></code></td> 
    <td>An interpolator whose change flings forward and overshoots the last value then comes back.</td> 
   </tr> 
   <tr> 
    <td><code><a href="../../../reference/android/animation/TimeInterpolator.html">TimeInterpolator</a></code></td> 
    <td>An interface that allows you to implement your own interpolator.</td> 
   </tr> 
  </tbody>
 </table> 
 ","package-summary","android.animation.package-summary","class",1
,"Property Animation","Animating with ObjectAnimator","<h2 id="object-animator">Animating with ObjectAnimator</h2> 
 <p>The <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> is a subclass of the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> (discussed in the previous section) and combines the timing engine and value computation of <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> with the ability to animate a named property of a target object. This makes animating any object much easier, as you no longer need to implement the <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html">ValueAnimator.AnimatorUpdateListener</a></code>, because the animated property updates automatically.</p> 
 <p>Instantiating an <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> is similar to a <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>, but you also specify the object and the name of that object's property (as a String) along with the values to animate between:</p> 
 <pre>
ObjectAnimator anim = ObjectAnimator.ofFloat(foo, &quot;alpha&quot;, 0f, 1f);
anim.setDuration(1000);
anim.start();
</pre> 
 <p>To have the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> update properties correctly, you must do the following:</p> 
 <ul> 
  <li>The object property that you are animating must have a setter function (in camel case) in the form of <code>set&lt;propertyName&gt;()</code>. Because the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> automatically updates the property during animation, it must be able to access the property with this setter method. For example, if the property name is <code>foo</code>, you need to have a <code>setFoo()</code> method. If this setter method does not exist, you have three options: 
   <ul> 
    <li>Add the setter method to the class if you have the rights to do so.</li> 
    <li>Use a wrapper class that you have rights to change and have that wrapper receive the value with a valid setter method and forward it to the original object.</li> 
    <li>Use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> instead.</li> 
   </ul> </li> 
  <li>If you specify only one value for the <code>values...</code> parameter in one of the <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> factory methods, it is assumed to be the ending value of the animation. Therefore, the object property that you are animating must have a getter function that is used to obtain the starting value of the animation. The getter function must be in the form of <code>get&lt;propertyName&gt;()</code>. For example, if the property name is <code>foo</code>, you need to have a <code>getFoo()</code> method.</li> 
  <li>The getter (if needed) and setter methods of the property that you are animating must operate on the same type as the starting and ending values that you specify to <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>. For example, you must have <code>targetObject.setPropName(float)</code> and <code>targetObject.getPropName(float)</code> if you construct the following <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>: <pre>
ObjectAnimator.ofFloat(targetObject, &quot;propName&quot;, 1f)
</pre> </li> 
  <li>Depending on what property or object you are animating, you might need to call the <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> method on a View to force the screen to redraw itself with the updated animated values. You do this in the <code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> callback. For example, animating the color property of a Drawable object only cause updates to the screen when that object redraws itself. All of the property setters on View, such as <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code> and <code><a href="../../../reference/android/view/View.html#setTranslationX(float)">setTranslationX()</a></code> invalidate the View properly, so you do not need to invalidate the View when calling these methods with new values. For more information on listeners, see the section about <a href="#listeners">Animation Listeners</a>. </li> 
 </ul> 
 ","AnimatorUpdateListener","android.animation.ValueAnimator.AnimatorUpdateListener","class",0
,"Property Animation","Animation Listeners","<h2 id="listeners">Animation Listeners</h2> 
 <p> You can listen for important events during an animation's duration with the listeners described below. </p> 
 <ul> 
  <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> 
   <ul> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationStart(android.animation.Animator)">onAnimationStart()</a></code> - Called when the animation starts.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code> - Called when the animation ends.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationRepeat(android.animation.Animator)">onAnimationRepeat()</a></code> - Called when the animation repeats itself.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationCancel(android.animation.Animator)">onAnimationCancel()</a></code> - Called when the animation is canceled. A cancelled animation also calls <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code>, regardless of how they were ended.</li> 
   </ul> </li> 
  <li><code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html">ValueAnimator.AnimatorUpdateListener</a></code> 
   <ul> 
    <li> <p><code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> - called on every frame of the animation. Listen to this event to use the calculated values generated by <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> during an animation. To use the value, query the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> object passed into the event to get the current animated value with the <code><a href="../../../reference/android/animation/ValueAnimator.html#getAnimatedValue()">getAnimatedValue()</a></code> method. Implementing this listener is required if you use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>. </p> <p> Depending on what property or object you are animating, you might need to call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> on a View to force that area of the screen to redraw itself with the new animated values. For example, animating the color property of a Drawable object only cause updates to the screen when that object redraws itself. All of the property setters on View, such as <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code> and <code><a href="../../../reference/android/view/View.html#setTranslationX(float)">setTranslationX()</a></code> invalidate the View properly, so you do not need to invalidate the View when calling these methods with new values. </p> </li> 
   </ul> </li> 
 </ul> 
 <p>You can extend the <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> class instead of implementing the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> interface, if you do not want to implement all of the methods of the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> interface. The <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> class provides empty implementations of the methods that you can choose to override.</p> 
 <p>For example, the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/BouncingBalls.html">Bouncing Balls</a> sample in the API demos creates an <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> for just the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code> callback:</p> 
 <pre>
ValueAnimatorAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, &quot;alpha&quot;, 1f, 0f);
fadeAnim.setDuration(250);
fadeAnim.addListener(new AnimatorListenerAdapter() {
public void onAnimationEnd(Animator animation) {
    balls.remove(((ObjectAnimator)animation).getTarget());
}
</pre> 
 ","AnimatorUpdateListener","android.animation.ValueAnimator.AnimatorUpdateListener","class",0
,"Property Animation","Animation Listeners","<h2 id="listeners">Animation Listeners</h2> 
 <p> You can listen for important events during an animation's duration with the listeners described below. </p> 
 <ul> 
  <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> 
   <ul> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationStart(android.animation.Animator)">onAnimationStart()</a></code> - Called when the animation starts.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code> - Called when the animation ends.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationRepeat(android.animation.Animator)">onAnimationRepeat()</a></code> - Called when the animation repeats itself.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationCancel(android.animation.Animator)">onAnimationCancel()</a></code> - Called when the animation is canceled. A cancelled animation also calls <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code>, regardless of how they were ended.</li> 
   </ul> </li> 
  <li><code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html">ValueAnimator.AnimatorUpdateListener</a></code> 
   <ul> 
    <li> <p><code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> - called on every frame of the animation. Listen to this event to use the calculated values generated by <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> during an animation. To use the value, query the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> object passed into the event to get the current animated value with the <code><a href="../../../reference/android/animation/ValueAnimator.html#getAnimatedValue()">getAnimatedValue()</a></code> method. Implementing this listener is required if you use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>. </p> <p> Depending on what property or object you are animating, you might need to call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> on a View to force that area of the screen to redraw itself with the new animated values. For example, animating the color property of a Drawable object only cause updates to the screen when that object redraws itself. All of the property setters on View, such as <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code> and <code><a href="../../../reference/android/view/View.html#setTranslationX(float)">setTranslationX()</a></code> invalidate the View properly, so you do not need to invalidate the View when calling these methods with new values. </p> </li> 
   </ul> </li> 
 </ul> 
 <p>You can extend the <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> class instead of implementing the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> interface, if you do not want to implement all of the methods of the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> interface. The <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> class provides empty implementations of the methods that you can choose to override.</p> 
 <p>For example, the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/BouncingBalls.html">Bouncing Balls</a> sample in the API demos creates an <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> for just the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code> callback:</p> 
 <pre>
ValueAnimatorAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, &quot;alpha&quot;, 1f, 0f);
fadeAnim.setDuration(250);
fadeAnim.addListener(new AnimatorListenerAdapter() {
public void onAnimationEnd(Animator animation) {
    balls.remove(((ObjectAnimator)animation).getTarget());
}
</pre> 
 ","AnimatorListener","android.animation.Animator.AnimatorListener","class",1
,"Property Animation","Animation Listeners","<h2 id="listeners">Animation Listeners</h2> 
 <p> You can listen for important events during an animation's duration with the listeners described below. </p> 
 <ul> 
  <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> 
   <ul> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationStart(android.animation.Animator)">onAnimationStart()</a></code> - Called when the animation starts.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code> - Called when the animation ends.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationRepeat(android.animation.Animator)">onAnimationRepeat()</a></code> - Called when the animation repeats itself.</li> 
    <li><code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationCancel(android.animation.Animator)">onAnimationCancel()</a></code> - Called when the animation is canceled. A cancelled animation also calls <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code>, regardless of how they were ended.</li> 
   </ul> </li> 
  <li><code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html">ValueAnimator.AnimatorUpdateListener</a></code> 
   <ul> 
    <li> <p><code><a href="../../../reference/android/animation/ValueAnimator.AnimatorUpdateListener.html#onAnimationUpdate(android.animation.ValueAnimator)">onAnimationUpdate()</a></code> - called on every frame of the animation. Listen to this event to use the calculated values generated by <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> during an animation. To use the value, query the <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code> object passed into the event to get the current animated value with the <code><a href="../../../reference/android/animation/ValueAnimator.html#getAnimatedValue()">getAnimatedValue()</a></code> method. Implementing this listener is required if you use <code><a href="../../../reference/android/animation/ValueAnimator.html">ValueAnimator</a></code>. </p> <p> Depending on what property or object you are animating, you might need to call <code><a href="../../../reference/android/view/View.html#invalidate()">invalidate()</a></code> on a View to force that area of the screen to redraw itself with the new animated values. For example, animating the color property of a Drawable object only cause updates to the screen when that object redraws itself. All of the property setters on View, such as <code><a href="../../../reference/android/view/View.html#setAlpha(float)">setAlpha()</a></code> and <code><a href="../../../reference/android/view/View.html#setTranslationX(float)">setTranslationX()</a></code> invalidate the View properly, so you do not need to invalidate the View when calling these methods with new values. </p> </li> 
   </ul> </li> 
 </ul> 
 <p>You can extend the <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> class instead of implementing the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> interface, if you do not want to implement all of the methods of the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html">Animator.AnimatorListener</a></code> interface. The <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> class provides empty implementations of the methods that you can choose to override.</p> 
 <p>For example, the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/BouncingBalls.html">Bouncing Balls</a> sample in the API demos creates an <code><a href="../../../reference/android/animation/AnimatorListenerAdapter.html">AnimatorListenerAdapter</a></code> for just the <code><a href="../../../reference/android/animation/Animator.AnimatorListener.html#onAnimationEnd(android.animation.Animator)">onAnimationEnd()</a></code> callback:</p> 
 <pre>
ValueAnimatorAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, &quot;alpha&quot;, 1f, 0f);
fadeAnim.setDuration(250);
fadeAnim.addListener(new AnimatorListenerAdapter() {
public void onAnimationEnd(Animator animation) {
    balls.remove(((ObjectAnimator)animation).getTarget());
}
</pre> 
 ","AnimatorListenerAdapter","android.animation.AnimatorListenerAdapter","class",1
,"Property Animation","Animating Layout Changes to ViewGroups","<h2 id="layout">Animating Layout Changes to ViewGroups</h2> 
 <p>The property animation system provides the capability to animate changes to ViewGroup objects as well as provide an easy way to animate View objects themselves.</p> 
 <p>You can animate layout changes within a ViewGroup with the <code><a href="../../../reference/android/animation/LayoutTransition.html">LayoutTransition</a></code> class. Views inside a ViewGroup can go through an appearing and disappearing animation when you add them to or remove them from a ViewGroup or when you call a View's <code><a href="../../../reference/android/view/View.html#setVisibility(int)">setVisibility()</a></code> method with <code><a href="../../../reference/android/view/View.html#VISIBLE">VISIBLE</a></code>, android.view.View#INVISIBLE}, or <code><a href="../../../reference/android/view/View.html#GONE">GONE</a></code>. The remaining Views in the ViewGroup can also animate into their new positions when you add or remove Views. You can define the following animations in a <code><a href="../../../reference/android/animation/LayoutTransition.html">LayoutTransition</a></code> object by calling <code><a href="../../../reference/android/animation/LayoutTransition.html#setAnimator(int, android.animation.Animator)">setAnimator()</a></code> and passing in an <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> object with one of the following <code><a href="../../../reference/android/animation/LayoutTransition.html">LayoutTransition</a></code> constants:</p> 
 <ul> 
  <li><code>APPEARING</code> - A flag indicating the animation that runs on items that are appearing in the container.</li> 
  <li><code>CHANGE_APPEARING</code> - A flag indicating the animation that runs on items that are changing due to a new item appearing in the container.</li> 
  <li><code>DISAPPEARING</code> - A flag indicating the animation that runs on items that are disappearing from the container.</li> 
  <li><code>CHANGE_DISAPPEARING</code> - A flag indicating the animation that runs on items that are changing due to an item disappearing from the container.</li> 
 </ul> 
 <p>You can define your own custom animations for these four types of events to customize the look of your layout transitions or just tell the animation system to use the default animations.</p> 
 <p>The <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/LayoutAnimations.html"> LayoutAnimations</a> sample in API Demos shows you how to define animations for layout transitions and then set the animations on the View objects that you want to animate.</p> 
 <p>The <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/LayoutAnimationsByDefault.html"> LayoutAnimationsByDefault</a> and its corresponding <a href="../../../resources/samples/ApiDemos/res/layout/layout_animations_by_default.html">layout_animations_by_default.xml</a> layout resource file show you how to enable the default layout transitions for ViewGroups in XML. The only thing that you need to do is to set the <code>android:animateLayoutchanges</code> attribute to <code>true</code> for the ViewGroup. For example:</p> 
 <pre>
&lt;LinearLayout
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;match_parent&quot;
    android:id=&quot;@+id/verticalContainer&quot;
    android:animateLayoutChanges=&quot;true&quot; /&gt;
</pre> 
 <p>Setting this attribute to true automatically animates Views that are added or removed from the ViewGroup as well as the remaining Views in the ViewGroup.</p> 
 ","LayoutTransition","android.animation.LayoutTransition","class",0
,"Property Animation","Specifying Keyframes","<h2 id="keyframes">Specifying Keyframes</h2> 
 <p>A <code><a href="../../../reference/android/animation/Keyframe.html">Keyframe</a></code> object consists of a time/value pair that lets you define a specific state at a specific time of an animation. Each keyframe can also have its own interpolator to control the behavior of the animation in the interval between the previous keyframe's time and the time of this keyframe.</p> 
 <p>To instantiate a <code><a href="../../../reference/android/animation/Keyframe.html">Keyframe</a></code> object, you must use one of the factory methods, <code><a href="../../../reference/android/animation/Keyframe.html#ofInt(float)">ofInt()</a></code>, <code><a href="../../../reference/android/animation/Keyframe.html#ofFloat(float)">ofFloat()</a></code>, or <code><a href="../../../reference/android/animation/Keyframe.html#ofObject(float)">ofObject()</a></code> to obtain the appropriate type of <code><a href="../../../reference/android/animation/Keyframe.html">Keyframe</a></code>. You then call the <code><a href="../../../reference/android/animation/PropertyValuesHolder.html#ofKeyframe(android.util.Property, android.animation.Keyframe...)">ofKeyframe()</a></code> factory method to obtain a <code><a href="../../../reference/android/animation/PropertyValuesHolder.html">PropertyValuesHolder</a></code> object. Once you have the object, you can obtain an animator by passing in the <code><a href="../../../reference/android/animation/PropertyValuesHolder.html">PropertyValuesHolder</a></code> object and the object to animate. The following code snippet demonstrates how to do this:</p> 
 <pre>
Keyframe kf0 = Keyframe.ofFloat(0f, 0f);
Keyframe kf1 = Keyframe.ofFloat(.5f, 360f);
Keyframe kf2 = Keyframe.ofFloat(1f, 0f);
PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(&quot;rotation&quot;, kf0, kf1, kf2);
ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation)
rotationAnim.setDuration(5000ms);
</pre> 
 <p>For a more complete example on how to use keyframes, see the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/MultiPropertyAnimation.html"> MultiPropertyAnimation</a> sample in APIDemos.</p> 
 ","PropertyValuesHolder","android.animation.PropertyValuesHolder","class",0
,"Property Animation","Specifying Keyframes","<h2 id="keyframes">Specifying Keyframes</h2> 
 <p>A <code><a href="../../../reference/android/animation/Keyframe.html">Keyframe</a></code> object consists of a time/value pair that lets you define a specific state at a specific time of an animation. Each keyframe can also have its own interpolator to control the behavior of the animation in the interval between the previous keyframe's time and the time of this keyframe.</p> 
 <p>To instantiate a <code><a href="../../../reference/android/animation/Keyframe.html">Keyframe</a></code> object, you must use one of the factory methods, <code><a href="../../../reference/android/animation/Keyframe.html#ofInt(float)">ofInt()</a></code>, <code><a href="../../../reference/android/animation/Keyframe.html#ofFloat(float)">ofFloat()</a></code>, or <code><a href="../../../reference/android/animation/Keyframe.html#ofObject(float)">ofObject()</a></code> to obtain the appropriate type of <code><a href="../../../reference/android/animation/Keyframe.html">Keyframe</a></code>. You then call the <code><a href="../../../reference/android/animation/PropertyValuesHolder.html#ofKeyframe(android.util.Property, android.animation.Keyframe...)">ofKeyframe()</a></code> factory method to obtain a <code><a href="../../../reference/android/animation/PropertyValuesHolder.html">PropertyValuesHolder</a></code> object. Once you have the object, you can obtain an animator by passing in the <code><a href="../../../reference/android/animation/PropertyValuesHolder.html">PropertyValuesHolder</a></code> object and the object to animate. The following code snippet demonstrates how to do this:</p> 
 <pre>
Keyframe kf0 = Keyframe.ofFloat(0f, 0f);
Keyframe kf1 = Keyframe.ofFloat(.5f, 360f);
Keyframe kf2 = Keyframe.ofFloat(1f, 0f);
PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(&quot;rotation&quot;, kf0, kf1, kf2);
ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation)
rotationAnim.setDuration(5000ms);
</pre> 
 <p>For a more complete example on how to use keyframes, see the <a href="../../../resources/samples/ApiDemos/src/com/example/android/apis/animation/MultiPropertyAnimation.html"> MultiPropertyAnimation</a> sample in APIDemos.</p> 
 ","Keyframe","android.animation.Keyframe","class",1
,"Animating Views","Animating with ViewPropertyAnimator","<h3 id="view-prop-animator">Animating with ViewPropertyAnimator</h3> 
 <p>The <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> provides a simple way to animate several properties of a <code><a href="../../../reference/android/view/View.html">View</a></code> in parallel, using a single underlying <code><a href="../../../reference/android/animation/Animator.html">Animator</a></code> object. It behaves much like an <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, because it modifies the actual values of the view's properties, but is more efficient when animating many properties at once. In addition, the code for using the <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> is much more concise and easier to read. The following code snippets show the differences in using multiple <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code> objects, a single <code><a href="../../../reference/android/animation/ObjectAnimator.html">ObjectAnimator</a></code>, and the <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code> when simultaneously animating the <code>x</code> and <code>y</code> property of a view.</p> 
 <p><strong>Multiple ObjectAnimator objects</strong></p> 
 <pre>
ObjectAnimator animX = ObjectAnimator.ofFloat(myView, &quot;x&quot;, 50f);
ObjectAnimator animY = ObjectAnimator.ofFloat(myView, &quot;y&quot;, 100f);
AnimatorSet animSetXY = new AnimatorSet();
animSetXY.playTogether(animX, animY);
animSetXY.start();
</pre> 
 <p><strong>One ObjectAnimator</strong></p> 
 <pre>
PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(&quot;x&quot;, 50f);
PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(&quot;y&quot;, 100f);
ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();
</pre> 
 <p><strong>ViewPropertyAnimator</strong></p> 
 <pre>
myView.animate().x(50f).y(100f);
</pre> 
 <p> For more detailed information about <code><a href="../../../reference/android/view/ViewPropertyAnimator.html">ViewPropertyAnimator</a></code>, see the corresponding Android Developers <a href="http://android-developers.blogspot.com/2011/05/introducing-viewpropertyanimator.html">blog post</a>.</p> 
 ","ViewPropertyAnimator","android.view.ViewPropertyAnimator","class",0
